local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Camera = Workspace.CurrentCamera
local lp = Players.LocalPlayer
local PlayerGui = lp:WaitForChild("PlayerGui")

-- Remotes with error handling
local testRemote = nil
local success, result = pcall(function()
    return ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)
if success then
    testRemote = result
else
    -- Try alternative paths
    success, result = pcall(function()
        return ReplicatedStorage:FindFirstChild("Network"):WaitForChild("RemoteEvent")
    end)
    if success then
        testRemote = result
    else
        testRemote = ReplicatedStorage:FindFirstChild("RemoteEvent") or Instance.new("RemoteEvent")
    end
end

-- Killers and Survivors folders with error handling
local KillersFolder = nil
local SurvivorsFolder = nil

local playersFolder = Workspace:FindFirstChild("Players")
if playersFolder then
    KillersFolder = playersFolder:FindFirstChild("Killers") or Instance.new("Folder")
    KillersFolder.Name = "Killers"
    SurvivorsFolder = playersFolder:FindFirstChild("Survivors") or Instance.new("Folder")
    SurvivorsFolder.Name = "Survivors"
else
    KillersFolder = Instance.new("Folder")
    KillersFolder.Name = "Killers"
    SurvivorsFolder = Instance.new("Folder")
    SurvivorsFolder.Name = "Survivors"
end

-- ===== UTILITY FUNCTIONS =====
local function SendNotif(title, text, duration)
    local success, err = pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title or "Auto Block",
            Text = text or "Notification",
            Duration = duration or 4
        })
    end)
end

-- ===== SOUND IDs FOR AUTO BLOCK =====
local autoBlockTriggerSounds = {
    ["102228729296384"] = true,
    ["124903763333174"] = true,
    ["128367348686124"] = true,
    ["104910828105172"] = true,
    ["140242176732868"] = true,
    ["112809109188560"] = true,
    ["115026634746636"] = true,
    ["84116622032112"] = true,
    ["108907358619313"] = true,
    ["127793641088496"] = true,
    ["105204810054381"] = true,
    ["86174610237192"] = true,
    ["95079963655241"] = true,
    ["101199185291628"] = true,
    ["119942598489800"] = true,
    ["84307400688050"] = true,
    ["113037804008732"] = true,
    ["105200830849301"] = true,
    ["75330693422988"] = true,
    ["124397369810639"] = true,
    ["107444859834748"] = true,
    ["82221759983649"] = true,
    ["76467993976301"] = true,
    ["81702359653578"] = true,
    ["128195973631079"] = true,
    ["108610718831698"] = true,
    ["112395455254818"] = true,
    ["109431876587852"] = true,
    ["109348678063422"] = true,
    ["85853080745515"] = true,
    ["86785901416030"] = true,
    ["12222216"] = true,
    ["105840448036441"] = true,
    ["114742322778642"] = true,
    ["119583605486352"] = true,
    ["79980897195554"] = true,
    ["71805956520207"] = true,
    ["131123355704017"] = true,
    ["79391273191671"] = true,
    ["89004992452376"] = true,
    ["101553872555606"] = true,
    ["98675142200448"] = true,
    ["101698569375359"] = true,
    ["106300477136129"] = true,
    ["116581754553533"] = true,
    ["117231507259853"] = true,
    ["119089145505438"] = true,
    ["121954639447247"] = true,
    ["125213046326879"] = true,
    ["131406927389838"] = true,
    ["117173212095661"] = true,
    ["80516583309685"] = true,
    -- Newly added sound IDs
    ["132596270805754"] = true,
    ["83851356262523"] = true,
    ["111910850942168"] = true,
    -- New Guest1337 auto block sounds
    ["136728245733659"] = true,
    ["94317217837143"] = true,
}

-- ===== KILLER-SPECIFIC HDT STOP TIMES =====
local killerHDTStopTimes = {
    ["Slasher"] = 0.25,
    ["JohnDoe"] = 0.45,
    ["c00lkidd"] = 0.15,
    ["1x1x1x1"] = 0.45,
    ["Noli"] = 0.4,
    ["Sixer"] = 0.4,
    ["Nosferatu"] = 0.35,
}

-- ===== STATE VARIABLES =====
local autoBlockForGuest = false
local autoBlockFor7n7 = false -- 007n7 auto clone state (toggled by keybind)
local ragingPaceAutoParry = false
local error404AutoParry = false
local ragingPaceAutoPunish = false
local onexOnexOnexOneAutoPunish = false
local doubleblocktech = false
local blockdelay = 0
local detectionRange = 18
local messageWhenAutoBlockOn = false
local messageWhenAutoBlock = ""
local blockChance = 100
local facingCheckEnabled = true
local customFacingDot = -0.3
local killerCirclesVisible = false
local guestBlockType = "Block" -- Only used for Guest1337 (Block or Charge)

-- ===== TRACK SOUND PLAYBACK STATE =====
local soundPlayingState = {} -- Stores whether each sound was playing last frame

-- ===== DUSEKKAR SILENT AIM VARIABLES =====
local dusekkarEnabled = false
local dusekkarTargetMode = "Survivors" -- "Survivors" or "Killers"
local silentAimActive = false
local originalGetMousePos = nil
local mousePositionModule = nil
local currentTarget = nil
local predictionMultiplier = 1.0 -- Default value (1 = normal prediction)
local predictionMin = 0.1  -- Minimum prediction factor
local predictionMax = 5.0  -- Maximum prediction factor

-- ===== HDT (HITBOX DRAGGING TECH) VARIABLES =====
local hitboxDraggingTech = false
local _hitboxDraggingDebounce = false
local HITBOX_DRAG_DURATION = 1.4
local HITBOX_DETECT_RADIUS = 6
local Dspeed = 5.6
local Ddelay = 0
local hdtActive = false
local hdtConnection = nil

-- ===== SPECIAL KILLER DETECTION =====
local isPlayingAsSpecialKiller = false
local currentKillerType = nil
local originalFacingCheckState = true

local KILLER_CONFIGS = {
    Slasher = {
        soundId = "12222225",
        abilityRemote = function()
            if testRemote then
                local args = {
                    "UseActorAbility",
                    {
                        buffer.fromstring("\003\n\000\000\000RagingPace")
                    }
                }
                local success, err = pcall(function()
                    testRemote:FireServer(unpack(args))
                end)
            end
        end,
        abilityName = "RagingPace"
    },
    JohnDoe = {
        soundId = "12222225",
        abilityRemote = function()
            if testRemote then
                local args = {
                    "UseActorAbility",
                    {
                        buffer.fromstring("\003\b\000\000\000404Error")
                    }
                }
                local success, err = pcall(function()
                    testRemote:FireServer(unpack(args))
                end)
            end
        end,
        abilityName = "404Error"
    },
    ["1x1x1x1"] = {
        abilityRemote = function()
            if testRemote then
                local args = {
                    "UseActorAbility",
                    {
                        buffer.fromstring("\003\r\000\000\000MassInfection")
                    }
                }
                local success, err = pcall(function()
                    testRemote:FireServer(unpack(args))
                end)
            end
        end,
        abilityName = "MassInfection"
    }
}

-- ===== PERFORMANCE CACHES =====
local detectionRangeSq = detectionRange * detectionRange
local cachedPunchBtn, cachedBlockBtn, cachedChargeBtn, cachedCloneBtn
local cachedCooldown
local detectionCircles = {}
local survivorCircles = {}
local _lastBlockMessageTime = 0
local MESSAGE_BLOCK_COOLDOWN = 0.6

-- ===== BASIC FUNCTIONS =====
local function refreshUIRefs()
    local main = PlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        if ability then
            cachedPunchBtn = ability:FindFirstChild("Punch")
            cachedBlockBtn = ability:FindFirstChild("Block")
            cachedChargeBtn = ability:FindFirstChild("Charge")
            cachedCloneBtn = ability:FindFirstChild("Clone")
            
            if cachedBlockBtn then
                cachedCooldown = cachedBlockBtn:FindFirstChild("CooldownTime")
            end
        end
    end
end

local function fireGuiBlock()
    if testRemote then
        local args = {
            "UseActorAbility",
            {
                buffer.fromstring("\003\005\000\000\000Block")
            }
        }
        pcall(function()
            testRemote:FireServer(unpack(args))
        end)
    end
end

local function fireGuiPunch()
    if testRemote then
        local args = {
            "UseActorAbility",
            {
                buffer.fromstring("\003\005\000\000\000Punch")
            }
        }
        pcall(function()
            testRemote:FireServer(unpack(args))
        end)
    end
end

local function fireGuiCharge()
    if testRemote then
        local args = {
            "UseActorAbility",
            {
                buffer.fromstring("\003\006\000\000\000Charge")
            }
        }
        pcall(function()
            testRemote:FireServer(unpack(args))
        end)
    end
end

local function fireGuiClone()
    if testRemote then
        local args = {
            "UseActorAbility",
            {
                buffer.fromstring("\003\005\000\000\000Clone")
            }
        }
        pcall(function()
            testRemote:FireServer(unpack(args))
        end)
    end
end

-- Function to check if the player is helpless (cannot block)
local function isHelpless()
    local success, helplessObj = pcall(function()
        return lp.PlayerGui.MainUI.AbilityContainer.Block:FindFirstChild("Helpless")
    end)
    
    if success and helplessObj then
        return true
    end
    return false
end

-- ===== HDT (HITBOX DRAGGING TECH) FUNCTIONS =====
-- Utility to safely get a killer HRP
local function getKillerHRP(killerModel)
    if not killerModel then return nil end
    if killerModel:FindFirstChild("HumanoidRootPart") then
        return killerModel:FindFirstChild("HumanoidRootPart")
    end
    if killerModel.PrimaryPart then
        return killerModel.PrimaryPart
    end
    -- try finding any basepart descendant
    return killerModel:FindFirstChildWhichIsA("BasePart", true)
end

-- Function to get the nearest killer model
local function getNearestKillerModel()
    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    local closest, closestDist = nil, math.huge
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        if killer and killer:IsA("Model") then
            local hrp = killer:FindFirstChild("HumanoidRootPart")
            if hrp then
                local d = (hrp.Position - myRoot.Position).Magnitude
                if d < closestDist then
                    closest, closestDist = killer, d
                end
            end
        end
    end
    return closest
end

-- Function to check if we have a punch charge (1)
local function hasPunchCharge()
    local success, charges = pcall(function()
        return lp.PlayerGui.MainUI.AbilityContainer.Punch.Charges.Text
    end)
    if success and charges then
        return charges == "1"
    end
    return false
end

-- Function to get killer-specific HDT stop time
local function getKillerHDTStopTime(killerModel)
    if not killerModel then return HITBOX_DRAG_DURATION end
    
    local killerName = killerModel.Name
    return killerHDTStopTimes[killerName] or HITBOX_DRAG_DURATION
end

-- Improved HDT function that aims towards killer and stops when punch charge is 1
local function beginDragIntoKiller(killerModel)
    -- Basic guards
    if _hitboxDraggingDebounce then return end
    if not killerModel or not killerModel.Parent then return end
    if not hitboxDraggingTech then return end -- Only run if HDT is enabled
    
    local char = lp and lp.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not humanoid then return end

    local targetHRP = getKillerHRP(killerModel)
    if not targetHRP then
        warn("beginDragIntoKiller: killer has no HRP/PrimaryPart")
        return
    end

    _hitboxDraggingDebounce = true
    hdtActive = true

    -- INSTANTLY AIM TOWARDS THE KILLER (HORIZONTAL ONLY)
    local killerPos = targetHRP.Position
    local myPos = hrp.Position
    
    -- Calculate direction to killer (only horizontal plane)
    local direction = (Vector3.new(killerPos.X, myPos.Y, killerPos.Z) - myPos).Unit
    
    -- Instantly set character rotation to face killer (without looking up/down)
    hrp.CFrame = CFrame.lookAt(myPos, myPos + direction)

    -- save old locomotion state so we can restore it
    local oldWalk = humanoid.WalkSpeed
    local oldJump = humanoid.JumpPower
    local oldPlatformStand = humanoid.PlatformStand

    -- block normal movement by zeroing walk/jump (works for mobile joystick too)
    humanoid.WalkSpeed = 0
    humanoid.JumpPower = 0
    humanoid.PlatformStand = false  -- keep physics normal so BodyVelocity works

    -- create BodyVelocity to push the HRP toward the killer smoothly
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5, 0, 1e5)     -- allow horizontal movement, keep y free
    bv.Velocity = Vector3.new(0,0,0)
    bv.Parent = hrp

    -- Get killer-specific stop time
    local killerStopTime = getKillerHDTStopTime(killerModel)

    -- Connection to update movement and check for stop conditions
    hdtConnection = RunService.Heartbeat:Connect(function(dt)
        if not hdtActive then
            if hdtConnection then
                hdtConnection:Disconnect()
                hdtConnection = nil
            end
            if bv and bv.Parent then pcall(function() bv:Destroy() end) end
            humanoid.WalkSpeed = oldWalk
            humanoid.JumpPower = oldJump
            humanoid.PlatformStand = oldPlatformStand
            _hitboxDraggingDebounce = false
            return
        end

        -- abort if character/killer removed
        if not (char and char.Parent) or not (killerModel and killerModel.Parent) then
            hdtActive = false
            return
        end

        -- refresh target HRP (killer may respawn)
        targetHRP = getKillerHRP(killerModel)
        if not targetHRP then
            hdtActive = false
            return
        end

        -- CONTINUOUSLY AIM TOWARDS THE KILLER while moving
        local currentKillerPos = targetHRP.Position
        local currentMyPos = hrp.Position
        local currentDirection = (Vector3.new(currentKillerPos.X, currentMyPos.Y, currentKillerPos.Z) - currentMyPos).Unit
        hrp.CFrame = CFrame.lookAt(currentMyPos, currentMyPos + currentDirection)

        -- compute desired horizontal velocity toward the target
        local toTarget = (targetHRP.Position - hrp.Position)
        local dist = toTarget.Magnitude
        
        local horiz = Vector3.new(toTarget.X, 0, toTarget.Z)
        if horiz.Magnitude > 0.01 then
            local dir = horiz.Unit
            bv.Velocity = Vector3.new(dir.X * Dspeed, bv.Velocity.Y, dir.Z * Dspeed)
        else
            bv.Velocity = Vector3.new(0, bv.Velocity.Y, 0)
        end

        -- STOP CONDITION 1: when very close to killer
        local stopDist = 2.0
        if dist <= stopDist then
            hdtActive = false
            return
        end

        -- STOP CONDITION 2: when punch charge becomes 1
        if hasPunchCharge() then
            hdtActive = false
            return
        end
    end)

    -- final cleanup safety (killer-specific timeout)
    task.delay(killerStopTime, function()
        if hdtActive then
            hdtActive = false
        end
    end)
end

-- ===== SILENT AIM HOOK SETUP =====
local function setupSilentAim()
    -- Try to require the mouse position module
    local success, module = pcall(function()
        return require(ReplicatedStorage:FindFirstChild("Systems"):FindFirstChild("Player"):FindFirstChild("Miscellaneous"):FindFirstChild("GetPlayerMousePosition"))
    end)
    
    if not success then
        -- Try alternative path
        success, module = pcall(function()
            return require(ReplicatedStorage.Systems.Player.Miscellaneous.GetPlayerMousePosition)
        end)
    end
    
    if success and module then
        mousePositionModule = module
        originalGetMousePos = module.GetMousePos
        
        -- Create hooked function with improved prediction from first script
        local function hookedGetMousePos(self, ...)
            local args = {...}
            local p1 = args[1] -- Prediction amount (provided by plasma beam)
            
            -- Check if silent aim is active and we have a target
            if silentAimActive and currentTarget then
                local targetHrp = currentTarget:FindFirstChild("HumanoidRootPart")
                if targetHrp then
                    -- Enhanced prediction based on the first script
                    if p1 then
                        local myChar = lp.Character
                        if myChar and myChar.PrimaryPart then
                            local distance = (targetHrp.Position - myChar.PrimaryPart.Position).Magnitude
                            local targetVelocity = targetHrp.AssemblyLinearVelocity
                            
                            -- Get base prediction amount from plasma beam
                            local basePredictionTime = typeof(p1) ~= "number" and 50 or p1
                            
                            -- Scale prediction based on distance (like in the first script)
                            local scaledPredictionTime = math.clamp(
                                basePredictionTime * (1 - math.min(distance / 100, 1)),
                                basePredictionTime / 3,
                                basePredictionTime * 3
                            )
                            
                            -- Apply prediction multiplier from slider
                            scaledPredictionTime = scaledPredictionTime * predictionMultiplier
                            
                            if targetVelocity.Magnitude == 0 then
                                return targetHrp.Position
                            else
                                return targetHrp.Position + targetVelocity * (distance / scaledPredictionTime)
                            end
                        end
                    end
                    return targetHrp.Position
                end
            end
            
            -- Otherwise use original function
            return originalGetMousePos(self, ...)
        end
        
        -- Replace the function
        module.GetMousePos = hookedGetMousePos
        return true
    end
    return false
end

local function restoreSilentAim()
    if mousePositionModule and originalGetMousePos then
        mousePositionModule.GetMousePos = originalGetMousePos
    end
end

-- ===== DUSEKKAR PLASMA BEAM FUNCTIONS =====
-- Check if I'm Dusekkar
local function amIDusekkar()
    -- Look for my character in Survivors folder with Dusekkar name
    if SurvivorsFolder then
        for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
            if survivor.Name == "Dusekkar" then
                local usernameAttr = survivor:GetAttribute("Username")
                if usernameAttr and usernameAttr == lp.Name then
                    return true
                end
            end
        end
    end
    return false
end

-- Check if plasma beam is on cooldown
local function isPlasmaBeamOnCooldown()
    local success, cooldownText = pcall(function()
        return lp.PlayerGui.MainUI.AbilityContainer.PlasmaBeam.CooldownTime.Text
    end)
    
    if success then
        -- If cooldown text is not empty and not "0", it's on cooldown
        return cooldownText ~= "" and cooldownText ~= "0"
    end
    return true -- Assume cooldown if we can't check
end

local function firePlasmaBeam()
    if not testRemote then return false end
    
    -- Check cooldown first
    if isPlasmaBeamOnCooldown() then
        return false
    end
    
    local args = {
        "UseActorAbility",
        {
            buffer.fromstring("\003\n\000\000\000PlasmaBeam")
        }
    }
    
    local success = pcall(function()
        testRemote:FireServer(unpack(args))
    end)
    
    if success then
        return true
    end
    return false
end

-- Function to find survivor closest to cursor
local function getSurvivorClosestToCursor()
    local myChar = lp.Character
    if not myChar then return nil end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    
    -- Get mouse position
    local mousePosition = UserInputService:GetMouseLocation()
    
    local validTargets = {}
    
    -- First, find all valid survivors
    for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
        -- Skip if this is me
        local usernameAttr = survivor:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            -- Skip this survivor
        else
            -- Check if survivor is alive
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local targetHrp = survivor:FindFirstChild("HumanoidRootPart")
                if targetHrp then
                    -- Check if survivor is on screen
                    local screenPos, onScreen = Camera:WorldToViewportPoint(targetHrp.Position)
                    
                    if onScreen then
                        -- Calculate distance from cursor to this survivor on screen
                        local screenVector = Vector2.new(screenPos.X, screenPos.Y)
                        local distanceToCursor = (screenVector - mousePosition).Magnitude
                        
                        table.insert(validTargets, {
                            survivor = survivor,
                            screenDistance = distanceToCursor
                        })
                    end
                end
            end
        end
    end
    
    -- Sort by screen distance (closest to cursor)
    table.sort(validTargets, function(a, b)
        return a.screenDistance < b.screenDistance
    end)
    
    -- Return the closest to cursor, or nil if none found
    if #validTargets > 0 then
        return validTargets[1].survivor
    end
    
    -- If no survivors on screen, fall back to nearest by world distance
    local nearestByDistance = nil
    local nearestDist = math.huge
    
    for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
        local usernameAttr = survivor:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            -- Skip this survivor
        else
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local targetHrp = survivor:FindFirstChild("HumanoidRootPart")
                if targetHrp then
                    local distance = (targetHrp.Position - myRoot.Position).Magnitude
                    if distance < nearestDist then
                        nearestDist = distance
                        nearestByDistance = survivor
                    end
                end
            end
        end
    end
    
    return nearestByDistance
end

-- Function to find the nearest killer
local function getNearestKiller()
    local myChar = lp.Character
    if not myChar then return nil end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    
    local nearestKiller = nil
    local nearestDistance = math.huge
    
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        -- Skip if this is me
        local usernameAttr = killer:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            -- Skip this killer
        else
            -- Target any killer model
            local targetHrp = killer:FindFirstChild("HumanoidRootPart")
            if targetHrp then
                -- Check if killer is alive
                local humanoid = killer:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local distance = (targetHrp.Position - myRoot.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestKiller = killer
                    end
                end
            end
        end
    end
    
    return nearestKiller
end

-- Function to use silent aim on target
local function useSilentAim()
    if not dusekkarEnabled then
        return false
    end
    
    -- Check if I'm Dusekkar first
    if not amIDusekkar() then
        return false
    end
    
    -- Find target based on mode
    local target = nil
    if dusekkarTargetMode == "Survivors" then
        target = getSurvivorClosestToCursor()
    else -- Killers mode
        target = getNearestKiller()
    end
    
    if not target then
        return false
    end
    
    -- Check if plasma beam is on cooldown
    if isPlasmaBeamOnCooldown() then
        return false
    end
    
    -- Set current target for silent aim (this will persist for the windup)
    currentTarget = target
    silentAimActive = true
    
    -- Fire the plasma beam (1.5 second windup starts now)
    local success = firePlasmaBeam()
    
    if success then
        SendNotif("Dusekkar", "Firing at " .. target.Name, 1)
        
        -- Keep the target active for 2.5 seconds (covers windup + firing + a little extra)
        -- The plasma beam has a 1.5s windup, then fires
        task.wait(2.5)
    end
    
    -- Clear target after firing is complete
    silentAimActive = false
    currentTarget = nil
    
    return success
end

-- ===== CHANCE-BASED BLOCKING =====
local function shouldBlock()
    if blockChance >= 100 then return true end
    if blockChance <= 0 then return false end
    return math.random(1, 100) <= blockChance
end

-- ===== FACING CHECK =====
local function isFacing(localRoot, targetRoot)
    if not facingCheckEnabled then return true end
    
    local dx = localRoot.Position.X - targetRoot.Position.X
    local dy = localRoot.Position.Y - targetRoot.Position.Y
    local dz = localRoot.Position.Z - targetRoot.Position.Z
    
    local mag = math.sqrt(dx*dx + dy*dy + dz*dz)
    if mag == 0 then return true end
    local invMag = 1 / mag
    
    local ux, uy, uz = dx * invMag, dy * invMag, dz * invMag
    local lv = targetRoot.CFrame.LookVector
    local dot = lv.X * ux + lv.Y * uy + lv.Z * uz
    
    return dot > customFacingDot
end

-- ===== SOUND CHECKING =====
local lastBlockTime = 0
local BLOCK_COOLDOWN = 0.7

local function extractNumericSoundId(sound)
    if not sound then return nil end
    local sid = tostring(sound.SoundId)
    
    local num = sid:match("rbxassetid://(%d+)") or
                sid:match("://(%d+)") or
                sid:match("^(%d+)$")
    return num
end

-- ===== GET ALL CHARACTERS WITH SPECIFIC NAME =====
local function getAllCharactersByName(name)
    local characters = {}
    
    if name == "Shedletsky" or name == "Guest1337" or name == "TwoTime" or name == "Chance" or name == "007n7" then
        if SurvivorsFolder then
            for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
                if survivor.Name == name then
                    table.insert(characters, survivor)
                end
            end
        end
    elseif name == "Slasher" or name == "JohnDoe" or name == "1x1x1x1" then
        if KillersFolder then
            for _, killer in ipairs(KillersFolder:GetChildren()) do
                if killer.Name == name then
                    table.insert(characters, killer)
                end
            end
        end
    end
    
    return characters
end

-- ===== CHECK IF PLAYING AS GUEST1337 =====
local function amIGuest1337()
    if SurvivorsFolder then
        for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
            if survivor.Name == "Guest1337" then
                local usernameAttr = survivor:GetAttribute("Username")
                if usernameAttr and usernameAttr == lp.Name then
                    return true, survivor
                end
            end
        end
    end
    return false, nil
end

-- ===== CHECK IF PLAYING AS 007N7 =====
local function amI007n7()
    if SurvivorsFolder then
        for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
            if survivor.Name == "007n7" then
                local usernameAttr = survivor:GetAttribute("Username")
                if usernameAttr and usernameAttr == lp.Name then
                    return true, survivor
                end
            end
        end
    end
    return false, nil
end

-- ===== SPECIAL KILLER AUTO PARRY =====
local lastSpecialAbilityTime = 0
local SPECIAL_ABILITY_COOLDOWN = 1.0

local function checkSpecialKillerAutoParry()
    if not isPlayingAsSpecialKiller or not currentKillerType then return end
    
    local now = tick()
    if now - lastSpecialAbilityTime < SPECIAL_ABILITY_COOLDOWN then return end
    
    local config = KILLER_CONFIGS[currentKillerType]
    if not config then return end
    
    local myChar = lp.Character
    if not myChar then return end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    local shouldUseAbility = false
    local targetKiller = nil
    
    -- Table of sound IDs that trigger special killer abilities
    local triggerSoundIds = {
        -- Shedletsky sounds
        ["12222225"] = true,
        ["132596270805754"] = true,
        ["83851356262523"] = true,
        ["111910850942168"] = true,
        ["115267992424648"] = true,
        -- TwoTime sounds
        ["99820161736138"] = true,
        ["86710781315432"] = true,
        -- Chance specific sound (only this one)
        ["139012439429121"] = true,
    }
    
    -- Check Shedletsky sounds (FIXED 20 range - NOT detectionRange)
    if (currentKillerType == "Slasher" and ragingPaceAutoParry) or 
       (currentKillerType == "JohnDoe" and error404AutoParry) then
        
        local allShedletskies = getAllCharactersByName("Shedletsky")
        
        for _, shedletsky in ipairs(allShedletskies) do
            local shedletskyHrp = shedletsky:FindFirstChild("HumanoidRootPart")
            if shedletskyHrp then
                -- USING FIXED 20, NOT detectionRange
                local distance = (shedletskyHrp.Position - myRoot.Position).Magnitude
                if distance <= 20 then
                    for _, sound in ipairs(shedletsky:GetDescendants()) do
                        if sound:IsA("Sound") and sound.IsPlaying then
                            local soundId = extractNumericSoundId(sound)
                            if soundId and triggerSoundIds[soundId] then
                                shouldUseAbility = true
                                targetKiller = shedletsky
                                break
                            end
                        end
                    end
                    if shouldUseAbility then break end
                end
            end
        end
    end
    
    -- Check TwoTime sounds (FIXED 30 range - COMPLETELY SEPARATE from detectionRange)
    if not shouldUseAbility and 
       ((currentKillerType == "Slasher" and ragingPaceAutoParry) or 
        (currentKillerType == "JohnDoe" and error404AutoParry)) then
        
        local allTwoTimes = getAllCharactersByName("TwoTime")
        
        for _, twotime in ipairs(allTwoTimes) do
            local twotimeHrp = twotime:FindFirstChild("HumanoidRootPart")
            if twotimeHrp then
                -- USING FIXED 30, NOT detectionRange
                local distance = (twotimeHrp.Position - myRoot.Position).Magnitude
                if distance <= 30 then
                    for _, sound in ipairs(twotime:GetDescendants()) do
                        if sound:IsA("Sound") and sound.IsPlaying then
                            local soundId = extractNumericSoundId(sound)
                            if soundId and (soundId == "99820161736138" or soundId == "86710781315432") then
                                shouldUseAbility = true
                                targetKiller = twotime
                                break
                            end
                        end
                    end
                    if shouldUseAbility then break end
                end
            end
        end
    end
    
    -- Check Chance - BOTH AUDIO AND ANIMATION DETECTION (FIXED 90 range)
    if not shouldUseAbility and 
       ((currentKillerType == "Slasher" and ragingPaceAutoParry) or 
        (currentKillerType == "JohnDoe" and error404AutoParry)) then
        
        local allChances = getAllCharactersByName("Chance")
        
        for _, chance in ipairs(allChances) do
            local chanceHrp = chance:FindFirstChild("HumanoidRootPart")
            if chanceHrp then
                -- USING FIXED 90, NOT detectionRange
                local distance = (chanceHrp.Position - myRoot.Position).Magnitude
                if distance <= 90 then
                    
                    -- Check Chance's sounds first (specific audio ID: 139012439429121)
                    for _, sound in ipairs(chance:GetDescendants()) do
                        if sound:IsA("Sound") and sound.IsPlaying then
                            local soundId = extractNumericSoundId(sound)
                            if soundId and soundId == "139012439429121" then
                                shouldUseAbility = true
                                targetKiller = chance
                                break
                            end
                        end
                    end
                    
                    -- If sound not found, check Chance's animations
                    if not shouldUseAbility then
                        local humanoid = chance:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            local animator = humanoid:FindFirstChildOfClass("Animator")
                            if animator then
                                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                                    local animId = tostring(track.Animation.AnimationId):match("%d+")
                                    -- Check for the specific animation IDs
                                    if animId == "133491532453922" or 
                                       animId == "86371356500204" or 
                                       animId == "131189930305001" then
                                        shouldUseAbility = true
                                        targetKiller = chance
                                        break
                                    end
                                end
                            end
                        end
                    end
                    
                    if shouldUseAbility then break end
                end
            end
        end
    end
    
    -- Slasher Auto Punish (animations from Guest1337) - uses detectionRange
    if not shouldUseAbility and currentKillerType == "Slasher" and ragingPaceAutoPunish then
        local allGuest1337s = getAllCharactersByName("Guest1337")
        
        for _, guest1337 in ipairs(allGuest1337s) do
            local guest1337Hrp = guest1337:FindFirstChild("HumanoidRootPart")
            if guest1337Hrp then
                local distance = (guest1337Hrp.Position - myRoot.Position).Magnitude
                if distance <= detectionRange then
                    local hum = guest1337:FindFirstChildOfClass("Humanoid")
                    if hum then
                        local animator = hum:FindFirstChildOfClass("Animator")
                        if animator then
                            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                                local id = tostring(track.Animation.AnimationId):match("%d+")
                                if id then
                                    local slasherAnims = {
                                        ["95802026624883"] = true,
                                        ["82036084568393"] = true,
                                        ["120748030255574"] = true,
                                        ["72722244508749"] = true,
                                        ["140671644163156"] = true,
                                        ["100926346851492"] = true,
                                        ["96959123077498"] = true, -- New animation ID added
                                    }
                                    
                                    if slasherAnims[id] then
                                        shouldUseAbility = true
                                        targetKiller = guest1337
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if shouldUseAbility then break end
                end
            end
        end
    end
    
    -- 1x1x1x1 Auto Punish (animations from Guest1337) - uses detectionRange
    if not shouldUseAbility and currentKillerType == "1x1x1x1" and onexOnexOnexOneAutoPunish then
        local allGuest1337s = getAllCharactersByName("Guest1337")
        
        for _, guest1337 in ipairs(allGuest1337s) do
            local guest1337Hrp = guest1337:FindFirstChild("HumanoidRootPart")
            if guest1337Hrp then
                local distance = (guest1337Hrp.Position - myRoot.Position).Magnitude
                if distance <= detectionRange then
                    local hum = guest1337:FindFirstChildOfClass("Humanoid")
                    if hum then
                        local animator = hum:FindFirstChildOfClass("Animator")
                        if animator then
                            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                                local id = tostring(track.Animation.AnimationId):match("%d+")
                                if id then
                                    local guest1337BlockAnims = {
                                        ["95802026624883"] = true,
                                        ["82036084568393"] = true,
                                        ["120748030255574"] = true,
                                        ["72722244508749"] = true,
                                        ["140671644163156"] = true,
                                        ["100926346851492"] = true,
                                        ["96959123077498"] = true, -- New animation ID added
                                    }
                                    
                                    if guest1337BlockAnims[id] then
                                        shouldUseAbility = true
                                        targetKiller = guest1337
                                        break
                                    end
                                end
                            end
                        end
                    end
                    if shouldUseAbility then break end
                end
            end
        end
    end
    
    if shouldUseAbility then
        if blockdelay > 0 then
            task.wait(blockdelay)
        end
        
        local success = pcall(function()
            config.abilityRemote()
        end)
        
        if success then
            lastSpecialAbilityTime = now
            return true
        end
    end
    
    return false
end

-- ===== SPECIAL KILLER DETECTION =====
local function checkSpecialKillerStatus()
    local character = lp.Character
    if not character then 
        if isPlayingAsSpecialKiller then
            isPlayingAsSpecialKiller = false
            currentKillerType = nil
            facingCheckEnabled = originalFacingCheckState
        end
        return false
    end
    
    local allSlashers = getAllCharactersByName("Slasher")
    local allJohnDoes = getAllCharactersByName("JohnDoe")
    local allOnexOnexOnexOnes = getAllCharactersByName("1x1x1x1")
    
    for _, slasher in ipairs(allSlashers) do
        local usernameAttr = slasher:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            if not isPlayingAsSpecialKiller or currentKillerType ~= "Slasher" then
                isPlayingAsSpecialKiller = true
                currentKillerType = "Slasher"
                originalFacingCheckState = facingCheckEnabled
                facingCheckEnabled = false
            end
            return true
        end
    end
    
    for _, johnDoe in ipairs(allJohnDoes) do
        local usernameAttr = johnDoe:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            if not isPlayingAsSpecialKiller or currentKillerType ~= "JohnDoe" then
                isPlayingAsSpecialKiller = true
                currentKillerType = "JohnDoe"
                originalFacingCheckState = facingCheckEnabled
                facingCheckEnabled = false
            end
            return true
        end
    end
    
    for _, onexone in ipairs(allOnexOnexOnexOnes) do
        local usernameAttr = onexone:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            if not isPlayingAsSpecialKiller or currentKillerType ~= "1x1x1x1" then
                isPlayingAsSpecialKiller = true
                currentKillerType = "1x1x1x1"
                originalFacingCheckState = facingCheckEnabled
                facingCheckEnabled = false
            end
            return true
        end
    end
    
    if isPlayingAsSpecialKiller then
        isPlayingAsSpecialKiller = false
        currentKillerType = nil
        facingCheckEnabled = originalFacingCheckState
    end
    
    return false
end

-- ===== TRACK SOUND STARTS =====
local lastSoundTrigger = {} -- Stores the last time each sound type was triggered by each killer

-- ===== OPTIMIZED CHECK FOR ATTACK SOUNDS =====
-- Now only blocks when a sound JUST started playing
local function checkForAttackSounds()
    if (not autoBlockForGuest and not autoBlockFor7n7) then return end
    if isPlayingAsSpecialKiller then return end
    
    local now = tick()
    if now - lastBlockTime < BLOCK_COOLDOWN then return end
    
    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    if not KillersFolder then return end
    
    -- Check if we're playing as Guest1337 or 007n7
    local isGuest1337, guestChar = amIGuest1337()
    local is007n7, cloneChar = amI007n7()
    
    -- Check each killer
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        local usernameAttr = killer:GetAttribute("Username")
        if usernameAttr and usernameAttr == lp.Name then
            -- Skip self
        else
            local killerHrp = killer:FindFirstChild("HumanoidRootPart")
            if killerHrp then
                local distance = (killerHrp.Position - myRoot.Position).Magnitude
                local inRange = distance <= detectionRange
                
                -- Check all sounds for this killer
                for _, sound in ipairs(killer:GetDescendants()) do
                    if sound:IsA("Sound") and sound.IsPlaying then
                        local soundId = extractNumericSoundId(sound)
                        if soundId and autoBlockTriggerSounds[soundId] then
                            
                            -- Create a key combining killer and sound ID
                            local triggerKey = killer.Name .. "_" .. soundId
                            
                            -- Check if this sound was recently triggered (within last 2 seconds)
                            local lastTrigger = lastSoundTrigger[triggerKey] or 0
                            
                            -- If this is a new trigger (not seen in last 2 seconds)
                            if now - lastTrigger > 2 then
                                lastSoundTrigger[triggerKey] = now
                                
                                -- Only block if we're in range and facing conditions are met
                                if inRange and ((not facingCheckEnabled) or isFacing(myRoot, killerHrp)) then
                                    if shouldBlock() then
                                        if blockdelay > 0 then
                                            task.wait(blockdelay)
                                        end
                                        
                                        refreshUIRefs()
                                        
                                        if isHelpless() then
                                            break
                                        end
                                        
                                        -- Check Guest1337 auto block (Block or Charge)
                                        if autoBlockForGuest and isGuest1337 then
                                            if guestBlockType == "Block" then
                                                if cachedCooldown and cachedCooldown.Text == "" then
                                                    fireGuiBlock()
                                                    if doubleblocktech then
                                                        fireGuiPunch()
                                                    end
                                                    if messageWhenAutoBlockOn and tick() - _lastBlockMessageTime > MESSAGE_BLOCK_COOLDOWN then
                                                        _lastBlockMessageTime = tick()
                                                    end
                                                    lastBlockTime = now
                                                    
                                                    if hitboxDraggingTech then
                                                        task.wait(Ddelay)
                                                        task.spawn(function() beginDragIntoKiller(killer) end)
                                                    end
                                                    
                                                    return
                                                end
                                            elseif guestBlockType == "Charge" then
                                                if cachedChargeBtn and cachedChargeBtn:FindFirstChild("CooldownTime") and cachedChargeBtn.CooldownTime.Text == "" then
                                                    fireGuiCharge()
                                                    lastBlockTime = now
                                                    return
                                                end
                                            end
                                        end
                                        
                                        -- Check 007n7 auto block (Clone only)
                                        if autoBlockFor7n7 and is007n7 then
                                            if cachedCloneBtn and cachedCloneBtn:FindFirstChild("CooldownTime") and cachedCloneBtn.CooldownTime.Text == "" then
                                                fireGuiClone()
                                                lastBlockTime = now
                                                return
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

-- ===== VISUAL RANGE =====
local lastVisualUpdate = 0
local VISUAL_UPDATE_COOLDOWN = 0.5

local function safeDestroyCircle(circle)
    if not circle then return end
    pcall(function()
        if circle.Parent then
            circle:Destroy()
        end
    end)
end

local function updateDetectionRangeVisuals()
    local now = tick()
    if now - lastVisualUpdate < VISUAL_UPDATE_COOLDOWN then return end
    lastVisualUpdate = now
    
    for _, circle in pairs(detectionCircles) do
        safeDestroyCircle(circle)
    end
    detectionCircles = {}
    
    for _, circle in pairs(survivorCircles) do
        safeDestroyCircle(circle)
    end
    survivorCircles = {}
    
    if not killerCirclesVisible then return end
    
    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    -- If playing as special killer, show circles on survivors with appropriate ranges
    if isPlayingAsSpecialKiller and currentKillerType then
        if SurvivorsFolder then
            for _, survivor in ipairs(SurvivorsFolder:GetChildren()) do
                local survivorHrp = survivor:FindFirstChild("HumanoidRootPart")
                if survivorHrp and not survivorHrp:FindFirstChild("DetectionCircle") then
                    
                    -- Determine the correct range based on survivor type
                    local visualRange = detectionRange -- Default to slider value
                    local circleColor = Color3.fromRGB(255, 255, 0) -- Default yellow
                    
                    if survivor.Name == "Chance" then
                        visualRange = 90
                        circleColor = Color3.fromRGB(255, 0, 255) -- Purple for Chance
                    elseif survivor.Name == "TwoTime" then
                        visualRange = 30
                        circleColor = Color3.fromRGB(0, 255, 255) -- Cyan for TwoTime
                    elseif survivor.Name == "Shedletsky" then
                        visualRange = 20 -- FIXED 20 range for Shedletsky
                        circleColor = Color3.fromRGB(0, 255, 0) -- Green for Shedletsky
                    elseif survivor.Name == "Guest1337" then
                        visualRange = detectionRange -- Uses slider
                        circleColor = Color3.fromRGB(255, 165, 0) -- Orange for Guest1337
                    elseif survivor.Name == "007n7" then
                        visualRange = detectionRange -- Uses slider
                        circleColor = Color3.fromRGB(128, 0, 128) -- Purple for 007n7
                    end
                    
                    local distance = (survivorHrp.Position - myRoot.Position).Magnitude
                    local inRange = distance <= visualRange
                    
                    pcall(function()
                        local circle = Instance.new("CylinderHandleAdornment")
                        circle.Name = "DetectionCircle"
                        circle.Adornee = survivorHrp
                        -- Change color based on in-range status
                        circle.Color3 = inRange and circleColor or Color3.fromRGB(128, 128, 128) -- Gray if out of range
                        circle.AlwaysOnTop = true
                        circle.ZIndex = 1
                        circle.Transparency = 0.6
                        circle.Radius = visualRange -- Use the specific range for this survivor
                        circle.Height = 0.12
                        
                        local yOffset = -(survivorHrp.Size.Y / 2 + 0.05)
                        circle.CFrame = CFrame.new(0, yOffset, 0) * CFrame.Angles(math.rad(90), 0, 0)
                        
                        circle.Parent = survivorHrp
                        survivorCircles[survivor] = circle
                    end)
                end
            end
        end
    else
        -- Regular mode - show circles on killers
        if KillersFolder then
            for _, killer in ipairs(KillersFolder:GetChildren()) do
                local killerHrp = killer:FindFirstChild("HumanoidRootPart")
                if killerHrp and not killerHrp:FindFirstChild("DetectionCircle") then
                    local usernameAttr = killer:GetAttribute("Username")
                    if usernameAttr and usernameAttr == lp.Name then
                        -- Skip this killer
                    else
                        local distance = (killerHrp.Position - myRoot.Position).Magnitude
                        local inRange = distance <= detectionRange
                        
                        pcall(function()
                            local circle = Instance.new("CylinderHandleAdornment")
                            circle.Name = "DetectionCircle"
                            circle.Adornee = killerHrp
                            circle.Color3 = inRange and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 165, 0)
                            circle.AlwaysOnTop = true
                            circle.ZIndex = 1
                            circle.Transparency = 0.6
                            circle.Radius = detectionRange
                            circle.Height = 0.12
                            
                            local yOffset = -(killerHrp.Size.Y / 2 + 0.05)
                            circle.CFrame = CFrame.new(0, yOffset, 0) * CFrame.Angles(math.rad(90), 0, 0)
                            
                            circle.Parent = killerHrp
                            detectionCircles[killer] = circle
                        end)
                    end
                end
            end
        end
    end
end

-- ===== MAIN LOOP =====
local mainLoopConn = RunService.Heartbeat:Connect(function()
    pcall(checkSpecialKillerStatus)
    
    if autoBlockForGuest or autoBlockFor7n7 then
        pcall(checkForAttackSounds)
    end
    
    if isPlayingAsSpecialKiller then
        pcall(checkSpecialKillerAutoParry)
    end
    
    if killerCirclesVisible then
        pcall(updateDetectionRangeVisuals)
    end
end)

-- ===== UI =====
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
    Name = "time for say gex",
    LoadingTitle = "loading gaming chair",
    LoadingSubtitle = "allat features (matthew gay included)",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "AutoBlockHub",
        FileName = "Settings"
    },
    Discord = {Enabled = false},
    KeySystem = false
})

local AutoBlockTab = Window:CreateTab("Auto Block", 4483362458)
local TechTab = Window:CreateTab("Techs", 4483362458)
local DusekkarTab = Window:CreateTab("Dusekkar Silent Aim", 4483362458)

AutoBlockTab:CreateToggle({
    Name = "1. Auto Block For Guest (Block/Charge)",
    CurrentValue = false,
    Flag = "AutoBlockForGuest",
    Callback = function(Value)
        autoBlockForGuest = Value
    end
})

-- Just a keybind for 007n7 - no toggle! Only works when playing as 007n7
AutoBlockTab:CreateKeybind({
    Name = "007n7 Toggle Keybind",
    CurrentKeybind = "F",
    HoldToInteract = false,
    Flag = "SevenNSevenKeybind",
    Callback = function()
        -- Check if we're actually playing as 007n7
        local is007n7 = amI007n7()
        
        if is007n7 then
            -- Toggle the 007n7 auto clone on/off
            autoBlockFor7n7 = not autoBlockFor7n7
            
            -- Send notification with the new state (only when playing as 007n7)
            if autoBlockFor7n7 then
                SendNotif("007n7", "Auto Clone ENABLED", 2)
            else
                SendNotif("007n7", "Auto Clone DISABLED", 2)
            end
        else
            -- Do absolutely nothing if not playing as 007n7
            -- No notifications, no toggling, just silence
        end
    end
})

AutoBlockTab:CreateToggle({
    Name = "2. Raging Pace Auto Parry (Slasher)",
    CurrentValue = false,
    Flag = "RagingPaceAutoParry",
    Callback = function(Value)
        ragingPaceAutoParry = Value
    end
})

AutoBlockTab:CreateToggle({
    Name = "3. Error 404 Auto Parry (JohnDoe)",
    CurrentValue = false,
    Flag = "Error404AutoParry",
    Callback = function(Value)
        error404AutoParry = Value
    end
})

AutoBlockTab:CreateToggle({
    Name = "4. Raging Pace Auto Punish (Slasher)",
    CurrentValue = false,
    Flag = "RagingPaceAutoPunish",
    Callback = function(Value)
        ragingPaceAutoPunish = Value
    end
})

AutoBlockTab:CreateToggle({
    Name = "5. Mass Infection Auto Punish (1x1x1x1)",
    CurrentValue = false,
    Flag = "OnexOnexOnexOneAutoPunish",
    Callback = function(Value)
        onexOnexOnexOneAutoPunish = Value
    end
})

AutoBlockTab:CreateSlider({
    Name = "Block Chance",
    Range = {0, 100},
    Increment = 5,
    Suffix = "%",
    CurrentValue = 100,
    Flag = "BlockChance",
    Callback = function(Value)
        blockChance = Value
    end
})

-- Change Guest1337 auto block type button
AutoBlockTab:CreateButton({
    Name = "Change Guest1337 auto block type",
    Callback = function()
        if guestBlockType == "Block" then
            guestBlockType = "Charge"
            SendNotif("Guest1337 Block Type", "Switched to Charge", 1.5)
        elseif guestBlockType == "Charge" then
            guestBlockType = "Block"
            SendNotif("Guest1337 Block Type", "Switched to Block", 1.5)
        end
    end
})

AutoBlockTab:CreateToggle({
    Name = "Message When Blocking",
    CurrentValue = false,
    Flag = "MessageWhenBlockToggle",
    Callback = function(Value)
        messageWhenAutoBlockOn = Value
    end
})

AutoBlockTab:CreateInput({
    Name = "Block Delay",
    PlaceholderText = "0",
    RemoveTextAfterFocusLost = false,
    Flag = "blockdelaynumber",
    Callback = function(Text)
        blockdelay = tonumber(Text) or 0
    end
})

AutoBlockTab:CreateInput({
    Name = "Message when blocking",
    PlaceholderText = "im gonna block ya",
    RemoveTextAfterFocusLost = false,
    Flag = "MessageWhenBlockText",
    Callback = function(Text)
        messageWhenAutoBlock = Text
    end
})

AutoBlockTab:CreateToggle({
    Name = "Enable Facing Check",
    CurrentValue = true,
    Flag = "FacingCheckToggle",
    Callback = function(Value)
        facingCheckEnabled = Value
        if not isPlayingAsSpecialKiller then
            originalFacingCheckState = Value
        end
    end
})

AutoBlockTab:CreateInput({
    Name = "Facing Check angle (DOT)",
    PlaceholderText = "-0.3",
    RemoveTextAfterFocusLost = false,
    Flag = "Facingcheckdot",
    Callback = function(Text)
        customFacingDot = tonumber(Text) or -0.3
    end
})

AutoBlockTab:CreateInput({
    Name = "Detection Range",
    PlaceholderText = "18",
    RemoveTextAfterFocusLost = false,
    Flag = "DetectionRange",
    Callback = function(Text)
        detectionRange = tonumber(Text) or 18
        detectionRangeSq = detectionRange * detectionRange
    end
})

AutoBlockTab:CreateToggle({
    Name = "Range Visual",
    CurrentValue = false,
    Flag = "KillerCircleToggle",
    Callback = function(Value)
        killerCirclesVisible = Value
        if not Value then
            for _, circle in pairs(detectionCircles) do
                safeDestroyCircle(circle)
            end
            detectionCircles = {}
            
            for _, circle in pairs(survivorCircles) do
                safeDestroyCircle(circle)
            end
            survivorCircles = {}
        end
    end
})

TechTab:CreateToggle({
    Name = "Double Punch Tech",
    CurrentValue = false,
    Flag = "doubleblockTechtoggle",
    Callback = function(Value)
        doubleblocktech = Value
    end
})

-- HDT (Hitbox Dragging Tech) Toggle
TechTab:CreateToggle({
    Name = "HDT (Hitbox Dragging Tech)",
    CurrentValue = false,
    Flag = "HitboxDraggingToggle",
    Callback = function(Value)
        hitboxDraggingTech = Value
        if not Value and hdtActive then
            hdtActive = false
        end
        SendNotif("HDT", Value and "Enabled - Drags hitbox towards killer (Block only, stops when punch gained)" or "Disabled", 2)
    end
})

TechTab:CreateInput({
    Name = "HDT speed",
    PlaceholderText = "5.6",
    RemoveTextAfterFocusLost = false,
    Flag = "HDTspeed",
    Callback = function(Text)
        Dspeed = tonumber(Text) or 5.6
    end
})

TechTab:CreateInput({
    Name = "HDT delay",
    PlaceholderText = "0",
    RemoveTextAfterFocusLost = false,
    Flag = "HDTdelay",
    Callback = function(Text)
        Ddelay = tonumber(Text) or 0
    end
})

TechTab:CreateParagraph({
    Title = "Hitbox Dragging tech",
    Content = "Only triggers on Block (not Charge/Clone). Instantly aims at killer and drags you towards them. Stops automatically when you gain a punch charge."
})

TechTab:CreateButton({
    Name = "Fake Lag Tech",
    Callback = function()
        local char = lp.Character
        if not char then return end
        
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
        
        for _, t in ipairs(animator:GetPlayingAnimationTracks()) do
            local id = tostring(t.Animation.AnimationId):match("%d+")
            if id == "136252471123500" then
                t:Stop()
            end
        end
        
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://136252471123500"
        local track = animator:LoadAnimation(anim)
        track:Play()
    end
})

-- ===== DUSEKKAR SILENT AIM TAB =====
DusekkarTab:CreateToggle({
    Name = "Enable Dusekkar Silent Aim",
    CurrentValue = false,
    Flag = "DusekkarToggle",
    Callback = function(Value)
        dusekkarEnabled = Value
        if not Value then
            -- Restore original function when disabled
            restoreSilentAim()
            silentAimActive = false
            currentTarget = nil
        end
    end
})

DusekkarTab:CreateDropdown({
    Name = "Target Mode",
    Options = {"Survivors", "Killers"},
    CurrentOption = "Survivors",
    Flag = "DusekkarTargetMode",
    Callback = function(Option)
        dusekkarTargetMode = Option
        SendNotif("Dusekkar", "Now targeting: " .. Option, 1)
    end
})

-- NEW PREDICTION SLIDER (0.1 to 5.0) - matching the first script
DusekkarTab:CreateSlider({
    Name = "Prediction Slider",
    Range = {0.1, 5},
    Increment = 0.1,
    Suffix = "x",
    CurrentValue = 1.0,
    Flag = "DusekkarPrediction",
    Callback = function(Value)
        predictionMultiplier = Value
        SendNotif("Prediction", "Set to " .. Value .. "x", 1)
    end
})

DusekkarTab:CreateKeybind({
    Name = "Switch Target Mode",
    CurrentKeybind = "Q",
    HoldToInteract = false,
    Flag = "DusekkarKeybind",
    Callback = function()
        -- Only allow switching if playing as Dusekkar
        if not amIDusekkar() then
            return
        end
        
        -- Toggle between Survivors and Killers
        if dusekkarTargetMode == "Survivors" then
            dusekkarTargetMode = "Killers"
        else
            dusekkarTargetMode = "Survivors"
        end
        
        -- Show notification for mode switch
        SendNotif("Dusekkar", "Now targeting: " .. dusekkarTargetMode, 2)
    end
})

DusekkarTab:CreateKeybind({
    Name = "Fire Plasma Beam (Silent)",
    CurrentKeybind = "F",
    HoldToInteract = false,
    Flag = "DusekkarFireKey",
    Callback = function()
        if not dusekkarEnabled then
            return
        end
        useSilentAim()
    end
})

DusekkarTab:CreateParagraph({
    Title = "How Silent Aim Works",
    Content = "PURE SILENT AIM:\n\n" ..
              " NO camera movement\n" ..
              " NO shiftlock\n" ..
              " NO suspicious aiming\n\n" ..
              "How it works:\n" ..
              " Hooks into game's mouse position system\n" ..
              " Target stays locked for FULL 2.5 seconds\n" ..
              " Covers the 1.5s windup + firing time\n" ..
              " Includes velocity prediction\n\n" ..
              "NEW: Prediction Slider (0.1 - 5.0x)\n" ..
              " 1.0x = Normal prediction\n" ..
              " Higher values = Shoot further ahead\n" ..
              " Lower values = Shoot closer to current position\n" ..
              " Distance-based scaling (closer = less prediction)\n\n" ..
              "Instructions:\n" ..
              "1. Enable the toggle\n" ..
              "2. Adjust prediction slider as needed\n" ..
              "3. Press Q to switch between Survivors/Killers\n" ..
              "4. Press F to silently fire at target\n\n" ..
              "SURVIVOR MODE: Targets survivor closest to your cursor\n" ..
              "KILLER MODE: Targets nearest killer"
})

Rayfield:LoadConfiguration()

refreshUIRefs()

-- Setup silent aim hook when script starts
setupSilentAim()

-- Cleanup on script end
local function cleanup()
    restoreSilentAim()
    mainLoopConn:Disconnect()
end

print("wahoo wario time - 007n7 toggles with keybind only and only works when playing as 007n7!")
