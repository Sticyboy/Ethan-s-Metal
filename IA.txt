-- Load Rayfield Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Create Window
local Window = Rayfield:CreateWindow({
    Name = "super sigma gaming chair",
    LoadingTitle = "erm what the sigma",
    LoadingSubtitle = "me when the when the what",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "PlayerNPCHighlighter",
        FileName = "Settings"
    },
    Discord = {
        Enabled = false,
        Invite = "noinvitelink",
        RememberJoins = true
    },
    KeySystem = false,
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- Store highlights and billboards for toggling
local ActiveHighlights = {}
local ActiveBillboards = {}
local ActiveHealthConnections = {}
local HighlightingEnabled = false
local AimbotEnabled = false
local WallCheckEnabled = true
local TeamCheckEnabled = false
local AimbotFOV = 200
local AimbotSmoothness = 0.7
local LocalPlayer = Players.LocalPlayer
local CurrentTarget = nil
local FOVCircle = nil
local AimbotKey = Enum.UserInputType.MouseButton2 -- Default to right click

-- Key binding variables
local ListeningForKey = false
local KeybindButton = nil

-- Boss monitoring
local BossMonitorConnection = nil
local LastBossCount = 0

-- Safe Zone Platform
local SafeZonePlatform = nil
local SafeZoneCreated = false

-- Whitelist System
local WhitelistedPlayers = {}
local WhitelistEnabled = false

-- Aimbot target tracking
local currentAimTarget = nil  -- Store the current target while aiming
local isAiming = false        -- Track if we're currently aiming

-- Create Safe Zone Platform
local function createSafeZonePlatform()
    if SafeZonePlatform and SafeZonePlatform.Parent then
        SafeZonePlatform:Destroy()
    end
    
    SafeZonePlatform = Instance.new("Part")
    SafeZonePlatform.Name = "SafeZonePlatform"
    SafeZonePlatform.Anchored = true
    SafeZonePlatform.BottomSurface = Enum.SurfaceType.Smooth
    SafeZonePlatform.BrickColor = BrickColor.new("Bright green")
    SafeZonePlatform.CFrame = CFrame.new(9999, 50, 9999)
    SafeZonePlatform.Color = Color3.new(0.294118, 0.592157, 0.294118)
    SafeZonePlatform.Material = Enum.Material.Grass
    SafeZonePlatform.Parent = workspace
    SafeZonePlatform.Position = Vector3.new(9999, 50, 9999)
    SafeZonePlatform.Size = Vector3.new(100, 1, 100)
    SafeZonePlatform.TopSurface = Enum.SurfaceType.Smooth
    
    SafeZoneCreated = true
    
    return SafeZonePlatform
end

-- Teleport to Safe Zone
local function teleportToSafeZone()
    if not SafeZoneCreated or not SafeZonePlatform then
        Rayfield:Notify({
            Title = "Safe Zone Error",
            Content = "Safe Zone platform not created yet!",
            Duration = 3,
            Image = 4483362458
        })
        return
    end
    
    if not LocalPlayer.Character then
        Rayfield:Notify({
            Title = "Safe Zone Error",
            Content = "Character not found!",
            Duration = 3,
            Image = 4483362458
        })
        return
    end
    
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        Rayfield:Notify({
            Title = "Safe Zone Error",
            Content = "HumanoidRootPart not found!",
            Duration = 3,
            Image = 4483362458
        })
        return
    end
    
    -- Save current position before teleporting
    _G.safeZoneOriginalPosition = humanoidRootPart.Position
    
    -- Teleport to safe zone
    LocalPlayer.Character:MoveTo(SafeZonePlatform.Position + Vector3.new(0, 3, 0))
    
    Rayfield:Notify({
        Title = "Safe Zone",
        Content = "Teleported to Safe Zone!",
        Duration = 3,
        Image = 4483362458
    })
end

-- Teleport back from Safe Zone
local function teleportBackFromSafeZone()
    if not _G.safeZoneOriginalPosition then
        Rayfield:Notify({
            Title = "Safe Zone Error",
            Content = "No original position saved!",
            Duration = 3,
            Image = 4483362458
        })
        return
    end
    
    if not LocalPlayer.Character then
        Rayfield:Notify({
            Title = "Safe Zone Error",
            Content = "Character not found!",
            Duration = 3,
            Image = 4483362458
        })
        return
    end
    
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        Rayfield:Notify({
            Title = "Safe Zone Error",
            Content = "HumanoidRootPart not found!",
            Duration = 3,
            Image = 4483362458
        })
        return
    end
    
    -- Teleport back to original position
    LocalPlayer.Character:MoveTo(_G.safeZoneOriginalPosition)
    
    Rayfield:Notify({
        Title = "Safe Zone",
        Content = "Teleported back to original position!",
        Duration = 3,
        Image = 4483362458
    })
end

-- FOV Circle Visual - Stays centered on screen
local function createFOVCircle()
    if FOVCircle then
        FOVCircle:Remove()
    end
    
    local circle = Drawing.new("Circle")
    circle.Visible = true
    circle.Thickness = 2
    circle.Color = Color3.new(1, 1, 1)
    circle.Transparency = 1
    circle.Filled = false
    circle.Radius = AimbotFOV
    circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- Always center of screen
    circle.NumSides = 100
    
    FOVCircle = circle
    return circle
end

local function updateFOVCircle()
    if FOVCircle then
        FOVCircle.Radius = AimbotFOV
        FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- Always center of screen
    end
end

-- Function to get key name for display
local function getKeyName(inputType)
    if inputType == Enum.UserInputType.MouseButton1 then
        return "Left Click"
    elseif inputType == Enum.UserInputType.MouseButton2 then
        return "Right Click"
    elseif inputType == Enum.UserInputType.MouseButton3 then
        return "Middle Click"
    elseif inputType.Name:match("Keyboard") then
        return inputType.Name:gsub("Keyboard", "")
    else
        return tostring(inputType.Name)
    end
end

-- Function to start listening for key input
local function startKeyListen()
    ListeningForKey = true
    if KeybindButton then
        KeybindButton:Set("Press any key...")
    end
    Rayfield:Notify({
        Title = "Keybind",
        Content = "Press any key to set as aimbot key...",
        Duration = 3,
        Image = 4483362458
    })
end

-- Key input connection
local keyConnection
local function setupKeyListener()
    if keyConnection then
        keyConnection:Disconnect()
    end
    
    keyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if ListeningForKey then
            ListeningForKey = false
            AimbotKey = input.UserInputType
            
            if KeybindButton then
                KeybindButton:Set("Aimbot Key: " .. getKeyName(AimbotKey))
            end
            
            Rayfield:Notify({
                Title = "Keybind Set",
                Content = "Aimbot key set to: " .. getKeyName(AimbotKey),
                Duration = 3,
                Image = 4483362458
            })
        end
    end)
end

-- Team check functions
local function isOnSameTeam(player)
    if not TeamCheckEnabled then
        return false
    end
    
    local localPlayerTeam = LocalPlayer.Team
    local targetPlayerTeam = player.Team
    
    -- Check if both players are on the same team
    if localPlayerTeam and targetPlayerTeam then
        return localPlayerTeam == targetPlayerTeam
    end
    
    return false
end

-- Whitelist check function
local function isPlayerWhitelisted(player)
    if not WhitelistEnabled then
        return false
    end
    
    return WhitelistedPlayers[player.Name] == true
end

local function isHoldingItem()
    if not LocalPlayer.Character then
        return false
    end
    
    local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return false
    end
    
    -- Check if holding a tool
    local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool then
        return true
    end
    
    -- Alternative method: check for items in hands
    local rightHand = LocalPlayer.Character:FindFirstChild("RightHand") or LocalPlayer.Character:FindFirstChild("Right Arm")
    local leftHand = LocalPlayer.Character:FindFirstChild("LeftHand") or LocalPlayer.Character:FindFirstChild("Left Arm")
    
    if rightHand then
        for _, item in pairs(rightHand:GetChildren()) do
            if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("UnionOperation") then
                return true
            end
        end
    end
    
    if leftHand then
        for _, item in pairs(leftHand:GetChildren()) do
            if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("UnionOperation") then
                return true
            end
        end
    end
    
    return false
end

local function isAlive(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        return humanoid.Health > 0
    end
    
    local healthSource = character:FindFirstChild("health") or character:FindFirstChild("Health")
    if healthSource and (healthSource:IsA("IntValue") or healthSource:IsA("NumberValue")) then
        return healthSource.Value > 0
    end
    
    return true -- Assume alive if no health found
end

local function wallCheck(targetPosition)
    if not WallCheckEnabled then
        return false
    end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPosition - origin).Unit
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    
    local raycastResult = Workspace:Raycast(origin, direction * 1000, raycastParams)
    
    if raycastResult then
        -- Check if the hit is the target or something else
        local distanceToTarget = (targetPosition - origin).Magnitude
        local distanceToHit = (raycastResult.Position - origin).Magnitude
        
        -- If something is closer than the target, there's a wall in the way
        return distanceToHit < distanceToTarget - 1
    end
    
    return false -- No walls in the way
end

local function findHealthValue(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        return humanoid
    end
    
    local healthObj = character:FindFirstChild("health") or character:FindFirstChild("Health")
    if healthObj then
        if healthObj:IsA("IntValue") or healthObj:IsA("NumberValue") then
            return healthObj
        end
    end
    
    local attrHealth = character:GetAttribute("Health") or character:GetAttribute("health")
    if attrHealth then
        local fakeValue = Instance.new("NumberValue")
        fakeValue.Value = attrHealth
        fakeValue.Name = "Health"
        fakeValue.Parent = character
        return fakeValue
    end
    
    return nil
end

local function removeESP(character)
    if ActiveHighlights[character] then
        ActiveHighlights[character]:Destroy()
        ActiveHighlights[character] = nil
    end
    
    if ActiveBillboards[character] then
        ActiveBillboards[character]:Destroy()
        ActiveBillboards[character] = nil
    end
    
    if ActiveHealthConnections[character] then
        ActiveHealthConnections[character]:Disconnect()
        ActiveHealthConnections[character] = nil
    end
end

local function updateAllHighlights()
    for character, highlight in pairs(ActiveHighlights) do
        if highlight and highlight.Parent then
            local player = Players:GetPlayerFromCharacter(character)
            if player and player ~= LocalPlayer then
                if CurrentTarget and character == CurrentTarget then
                    highlight.FillColor = Color3.fromRGB(128, 0, 128) -- Purple for target
                    highlight.OutlineColor = Color3.fromRGB(200, 0, 200)
                else
                    if isPlayerWhitelisted(player) then
                        highlight.FillColor = Color3.fromRGB(0, 100, 255) -- Blue for whitelisted
                    elseif TeamCheckEnabled and isOnSameTeam(player) then
                        highlight.FillColor = Color3.fromRGB(0, 255, 0) -- Green for teammates
                    else
                        highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red for enemies
                    end
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                end
            else
                -- Check if it's a boss
                local isBoss = false
                local npcsFolder = Workspace:FindFirstChild("NPCs")
                if npcsFolder then
                    local bossFolder = npcsFolder:FindFirstChild("Boss")
                    if bossFolder then
                        for _, boss in pairs(bossFolder:GetChildren()) do
                            if boss == character then
                                isBoss = true
                                break
                            end
                        end
                    end
                end
                
                if isBoss then
                    highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red for bosses
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 0) -- Yellow outline for bosses
                else
                    highlight.FillColor = Color3.fromRGB(255, 255, 0) -- Yellow for regular NPCs
                    highlight.OutlineColor = Color3.new(1, 1, 1)
                end
            end
        end
    end
    
    -- Update billboard names as well
    for character, billboard in pairs(ActiveBillboards) do
        if billboard and billboard.Parent then
            local nameLabel = billboard:FindFirstChildOfClass("TextLabel")
            if nameLabel then
                local player = Players:GetPlayerFromCharacter(character)
                if player and player ~= LocalPlayer then
                    if isPlayerWhitelisted(player) then
                        nameLabel.TextColor3 = Color3.fromRGB(0, 100, 255)
                        nameLabel.Text = player.Name .. " (Whitelisted)"
                    elseif TeamCheckEnabled and isOnSameTeam(player) then
                        nameLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                        nameLabel.Text = player.Name .. " (Teammate)"
                    else
                        nameLabel.TextColor3 = Color3.new(1, 1, 1)
                        nameLabel.Text = player.Name
                    end
                else
                    -- Check if it's a boss
                    local isBoss = false
                    local npcsFolder = Workspace:FindFirstChild("NPCs")
                    if npcsFolder then
                        local bossFolder = npcsFolder:FindFirstChild("Boss")
                        if bossFolder then
                            for _, boss in pairs(bossFolder:GetChildren()) do
                                if boss == character then
                                    isBoss = true
                                    break
                                end
                            end
                        end
                    end
                    
                    if isBoss then
                        nameLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
                        nameLabel.Text = "BOSS: " .. character.Name
                    else
                        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
                        nameLabel.Text = "NPC: " .. character.Name
                    end
                end
            end
        end
    end
end

local function createHealthBar(entity, character, healthSource, isNPC)
    local billboard = Instance.new("BillboardGui")
    billboard.Adornee = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
    billboard.Size = UDim2.new(0, 120, 0, 40)
    billboard.StudsOffset = Vector3.new(0, 5, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = 500
    billboard.Parent = character
    
    local player = Players:GetPlayerFromCharacter(character)
    local isTeammate = player and TeamCheckEnabled and isOnSameTeam(player)
    local isWhitelisted = player and isPlayerWhitelisted(player)
    
    -- Check if it's a boss
    local isBoss = false
    local npcsFolder = Workspace:FindFirstChild("NPCs")
    if npcsFolder then
        local bossFolder = npcsFolder:FindFirstChild("Boss")
        if bossFolder then
            for _, boss in pairs(bossFolder:GetChildren()) do
                if boss == character then
                    isBoss = true
                    break
                end
            end
        end
    end
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0, 20)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextColor3 = isBoss and Color3.fromRGB(255, 0, 0) or (isNPC and Color3.fromRGB(255, 255, 0)) or (isWhitelisted and Color3.fromRGB(0, 100, 255)) or (isTeammate and Color3.fromRGB(0, 255, 0) or Color3.new(1, 1, 1))
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    
    if isBoss then
        nameLabel.Text = "BOSS: " .. character.Name
    elseif isNPC then
        nameLabel.Text = "NPC: " .. character.Name
    else
        if isWhitelisted then
            nameLabel.Text = entity.Name .. " (Whitelisted)"
        elseif isTeammate then
            nameLabel.Text = entity.Name .. " (Teammate)"
        else
            nameLabel.Text = entity.Name
        end
    end
    
    nameLabel.Parent = billboard
    
    local healthContainer = Instance.new("Frame")
    healthContainer.Size = UDim2.new(1, 0, 0, 15)
    healthContainer.Position = UDim2.new(0, 0, 0, 20)
    healthContainer.BackgroundColor3 = Color3.new(0, 0, 0)
    healthContainer.BorderSizePixel = 1
    healthContainer.BorderColor3 = Color3.new(1, 1, 1)
    healthContainer.Parent = billboard
    
    local healthBar = Instance.new("Frame")
    healthBar.Size = UDim2.new(1, 0, 1, 0)
    healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
    healthBar.BorderSizePixel = 0
    healthBar.Parent = healthContainer
    healthBar.ZIndex = 2
    
    local healthText = Instance.new("TextLabel")
    healthText.Size = UDim2.new(1, 0, 1, 0)
    healthText.BackgroundTransparency = 1
    healthText.TextScaled = true
    healthText.Font = Enum.Font.GothamMedium
    healthText.TextColor3 = Color3.new(1, 1, 1)
    healthText.TextStrokeTransparency = 0
    healthText.TextStrokeColor3 = Color3.new(0, 0, 0)
    healthText.Parent = healthContainer
    healthText.ZIndex = 3
    
    local function updateHealthBar()
        local currentHealth, maxHealth
        
        if healthSource:IsA("Humanoid") then
            currentHealth = healthSource.Health
            maxHealth = healthSource.MaxHealth
        elseif healthSource:IsA("IntValue") or healthSource:IsA("NumberValue") then
            currentHealth = healthSource.Value
            local maxHealthSource = character:FindFirstChild("MaxHealth") or character:FindFirstChild("maxHealth")
            maxHealth = maxHealthSource and maxHealthSource.Value or 100
        else
            currentHealth = 100
            maxHealth = 100
        end
        
        local healthPercentage = math.clamp(currentHealth / maxHealth, 0, 1)
        
        healthBar.Size = UDim2.new(healthPercentage, 0, 1, 0)
        
        if healthPercentage > 0.6 then
            healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
        elseif healthPercentage > 0.3 then
            healthBar.BackgroundColor3 = Color3.new(1, 1, 0)
        else
            healthBar.BackgroundColor3 = Color3.new(1, 0, 0)
        end
        
        healthText.Text = math.floor(currentHealth) .. "/" .. math.floor(maxHealth)
        
        -- Remove ESP if health is 0 or below
        if currentHealth <= 0 then
            removeESP(character)
        end
    end
    
    -- Store the connection for cleanup
    if healthSource:IsA("Humanoid") then
        ActiveHealthConnections[character] = healthSource:GetPropertyChangedSignal("Health"):Connect(updateHealthBar)
    elseif healthSource:IsA("IntValue") or healthSource:IsA("NumberValue") then
        ActiveHealthConnections[character] = healthSource.Changed:Connect(updateHealthBar)
    end
    
    updateHealthBar()
    
    ActiveBillboards[character] = billboard
    
    return billboard
end

local function highlightEntity(entity, character, isNPC)
    if not character or (not isNPC and entity == LocalPlayer) then return nil end -- Skip highlighting yourself
    
    local healthSource = findHealthValue(character)
    if not healthSource then
        return nil
    end
    
    -- Check if already dead
    local currentHealth = 0
    if healthSource:IsA("Humanoid") then
        currentHealth = healthSource.Health
    elseif healthSource:IsA("IntValue") or healthSource:IsA("NumberValue") then
        currentHealth = healthSource.Value
    end
    
    if currentHealth <= 0 then
        return nil -- Don't highlight dead entities
    end
    
    -- Check if it's a boss
    local isBoss = false
    local npcsFolder = Workspace:FindFirstChild("NPCs")
    if npcsFolder then
        local bossFolder = npcsFolder:FindFirstChild("Boss")
        if bossFolder then
            for _, boss in pairs(bossFolder:GetChildren()) do
                if boss == character then
                    isBoss = true
                    break
                end
            end
        end
    end
    
    -- Determine highlight color based on type
    local fillColor, outlineColor
    if isBoss then
        fillColor = Color3.fromRGB(255, 0, 0) -- Red for bosses
        outlineColor = Color3.fromRGB(255, 255, 0) -- Yellow outline for bosses
    elseif isNPC then
        fillColor = Color3.fromRGB(255, 255, 0) -- Yellow for NPCs
        outlineColor = Color3.new(1, 1, 1)
    else
        local player = entity
        
        -- Check if player is whitelisted
        if isPlayerWhitelisted(player) then
            fillColor = Color3.fromRGB(0, 100, 255) -- Blue for whitelisted players
            outlineColor = Color3.new(1, 1, 1)
        elseif TeamCheckEnabled and isOnSameTeam(player) then
            fillColor = Color3.fromRGB(0, 255, 0) -- Green for teammates
            outlineColor = Color3.new(1, 1, 1)
        else
            fillColor = Color3.fromRGB(255, 0, 0) -- Red for enemies
            outlineColor = Color3.new(1, 1, 1)
        end
    end
    
    -- Create highlight
    local highlight = Instance.new("Highlight")
    highlight.Adornee = character
    highlight.FillColor = fillColor
    highlight.OutlineColor = outlineColor
    highlight.FillTransparency = 0.3
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = character
    
    -- Create health bar with name
    createHealthBar(entity, character, healthSource, isNPC or isBoss)
    
    ActiveHighlights[character] = highlight
    
    return highlight
end

local function removeAllHighlights()
    for character, highlight in pairs(ActiveHighlights) do
        if highlight then
            highlight:Destroy()
        end
    end
    
    for character, billboard in pairs(ActiveBillboards) do
        if billboard then
            billboard:Destroy()
        end
    end
    
    for character, connection in pairs(ActiveHealthConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    
    ActiveHighlights = {}
    ActiveBillboards = {}
    ActiveHealthConnections = {}
    CurrentTarget = nil
end

local function processExistingPlayers()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player ~= LocalPlayer then
            highlightEntity(player, player.Character, false)
        end
    end
end

local function processExistingNPCs()
    -- Check NPCs folder
    local npcsFolder = Workspace:FindFirstChild("NPCs")
    if npcsFolder then
        -- Regular NPCs (not in boss folder)
        for _, npc in pairs(npcsFolder:GetChildren()) do
            if npc:IsA("Model") and npc.Name ~= "Boss" then
                highlightEntity(npc, npc, true)
            end
        end
        
        -- Boss NPCs
        local bossFolder = npcsFolder:FindFirstChild("Boss")
        if bossFolder then
            for _, boss in pairs(bossFolder:GetChildren()) do
                if boss:IsA("Model") then
                    highlightEntity(boss, boss, true)
                end
            end
        end
    end
end

-- Function to check for new bosses and update ESP
local function checkForNewBosses()
    local npcsFolder = Workspace:FindFirstChild("NPCs")
    if not npcsFolder then return 0 end
    
    local bossFolder = npcsFolder:FindFirstChild("Boss")
    if not bossFolder then return 0 end
    
    local currentBossCount = 0
    local newBossesFound = false
    
    for _, boss in pairs(bossFolder:GetChildren()) do
        if boss:IsA("Model") then
            currentBossCount = currentBossCount + 1
            -- Check if this boss is not already highlighted
            if not ActiveHighlights[boss] and isAlive(boss) then
                newBossesFound = true
                highlightEntity(boss, boss, true)
                print("New boss detected and highlighted: " .. boss.Name)
            end
        end
    end
    
    -- Check if bosses were removed (clean up ESP for dead/removed bosses)
    for character, _ in pairs(ActiveHighlights) do
        local isBoss = false
        if bossFolder then
            for _, boss in pairs(bossFolder:GetChildren()) do
                if boss == character then
                    isBoss = true
                    break
                end
            end
        end
        
        if isBoss and (not character.Parent or not isAlive(character)) then
            removeESP(character)
            print("Removed ESP for boss: " .. character.Name)
        end
    end
    
    return currentBossCount, newBossesFound
end

-- Start boss monitoring
local function startBossMonitoring()
    if BossMonitorConnection then
        BossMonitorConnection:Disconnect()
    end
    
    BossMonitorConnection = RunService.Heartbeat:Connect(function()
        if HighlightingEnabled then
            local currentBossCount, newBossesFound = checkForNewBosses()
            
            -- If boss count changed or new bosses found, update LastBossCount
            if currentBossCount ~= LastBossCount or newBossesFound then
                LastBossCount = currentBossCount
            end
        end
    end)
end

-- Stop boss monitoring
local function stopBossMonitoring()
    if BossMonitorConnection then
        BossMonitorConnection:Disconnect()
        BossMonitorConnection = nil
    end
end

-- FIXED: Improved boss targeting function
local function getBossTargetPart(boss)
    if not boss or not boss:IsA("Model") then
        return nil
    end
    
    -- For bosses, prioritize HEAD first, then fall back to HumanoidRootPart
    local head = boss:FindFirstChild("Head")
    if head then
        return head
    end
    
    -- If no head found, use HumanoidRootPart
    local humanoidRootPart = boss:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        return humanoidRootPart
    end
    
    -- Last resort: try torso or upper torso
    local torso = boss:FindFirstChild("Torso") or boss:FindFirstChild("UpperTorso")
    return torso
end

-- FIXED: Check if mouse is inside FOV circle
local function isMouseInFOV()
    local mouseLocation = UserInputService:GetMouseLocation()
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distanceFromCenter = (mouseLocation - screenCenter).Magnitude
    return distanceFromCenter <= AimbotFOV
end

-- FIXED: FOV check uses CENTER of screen for target distance
local function isTargetInFOV(targetPart)
    if not targetPart then
        return false
    end
    
    local targetPosition, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
    
    if not onScreen then
        return false
    end
    
    -- Calculate distance from CENTER of screen to target on screen
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
    
    -- Check if target is within FOV circle (using screen center as center)
    return distance <= AimbotFOV
end

-- FIXED: Unified target collection that checks ALL entities together using CENTER FOV
local function getAllValidTargets()
    local validTargets = {}
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    -- Check players
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and isAlive(player.Character) then
            -- Skip teammates if team check is enabled
            if TeamCheckEnabled and isOnSameTeam(player) then
                continue
            end
            
            -- Skip whitelisted players
            if isPlayerWhitelisted(player) then
                continue
            end
            
            -- Try to find head first, then torso, then humanoid root part
            local head = player.Character:FindFirstChild("Head")
            local torso = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso")
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            
            local targetPart = head or torso or humanoidRootPart
            if targetPart and isTargetInFOV(targetPart) then
                local targetPosition = Camera:WorldToViewportPoint(targetPart.Position)
                local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
                
                if not wallCheck(targetPart.Position) then
                    table.insert(validTargets, {
                        targetPart = targetPart,
                        character = player.Character,
                        distance = distance,
                        type = "player"
                    })
                end
            end
        end
    end
    
    -- Check NPCs folder
    local npcsFolder = Workspace:FindFirstChild("NPCs")
    if npcsFolder then
        -- Regular NPCs (not in boss folder)
        for _, npc in pairs(npcsFolder:GetChildren()) do
            if npc:IsA("Model") and npc.Name ~= "Boss" and isAlive(npc) then
                -- Skip if this NPC is actually yourself (when you're a boss)
                if npc == LocalPlayer.Character then
                    continue
                end
                
                local head = npc:FindFirstChild("Head")
                local torso = npc:FindFirstChild("Torso") or npc:FindFirstChild("UpperTorso")
                local humanoidRootPart = npc:FindFirstChild("HumanoidRootPart")
                
                local targetPart = head or torso or humanoidRootPart
                if targetPart and isTargetInFOV(targetPart) then
                    local targetPosition = Camera:WorldToViewportPoint(targetPart.Position)
                    local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
                    
                    if not wallCheck(targetPart.Position) then
                        table.insert(validTargets, {
                            targetPart = targetPart,
                            character = npc,
                            distance = distance,
                            type = "npc"
                        })
                    end
                end
            end
        end
        
        -- Boss NPCs
        local bossFolder = npcsFolder:FindFirstChild("Boss")
        if bossFolder then
            for _, boss in pairs(bossFolder:GetChildren()) do
                if boss:IsA("Model") and isAlive(boss) then
                    -- CRITICAL FIX: Skip targeting yourself when you're the boss
                    if boss == LocalPlayer.Character then
                        continue
                    end
                    
                    -- NEW FIX: Skip targeting the SILLYSTATUE boss
                    if string.lower(boss.Name) == "sillystatue" then
                        continue
                    end
                    
                    -- FIXED: Use the improved boss targeting function
                    local targetPart = getBossTargetPart(boss)
                    if targetPart and isTargetInFOV(targetPart) then
                        local targetPosition = Camera:WorldToViewportPoint(targetPart.Position)
                        local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
                        
                        if not wallCheck(targetPart.Position) then
                            table.insert(validTargets, {
                                targetPart = targetPart,
                                character = boss,
                                distance = distance,
                                type = "boss"
                            })
                        end
                    end
                end
            end
        end
    end
    
    return validTargets
end

-- FIXED: Aimbot target selection that picks the CLOSEST target to CENTER of screen
local function getClosestTargetToCursor()
    local validTargets = getAllValidTargets()
    
    local closestTarget = nil
    local closestCharacter = nil
    local closestDistance = math.huge
    
    -- Find the closest target from all valid targets (closest to center of screen)
    for _, targetData in pairs(validTargets) do
        if targetData.distance < closestDistance then
            closestDistance = targetData.distance
            closestTarget = targetData.targetPart
            closestCharacter = targetData.character
        end
    end
    
    return closestTarget, closestDistance, closestCharacter
end

local function aimAtTarget(targetPart)
    if not targetPart then return end
    
    -- Calculate the direction to the target part
    local camera = Workspace.CurrentCamera
    local targetPosition = targetPart.Position
    
    -- Create a CFrame that looks at the target
    local lookAt = CFrame.lookAt(camera.CFrame.Position, targetPosition)
    
    -- Smoothly interpolate the camera
    camera.CFrame = camera.CFrame:Lerp(lookAt, AimbotSmoothness)
end

-- Fixed Aimbot loop - NOW CHECKS IF MOUSE IS IN FOV
local aimbotConnection
local function startAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
    end
    
    aimbotConnection = RunService.RenderStepped:Connect(function()
        if AimbotEnabled and UserInputService:GetFocusedTextBox() == nil then
            local isAimbotKeyPressed = false
            
            -- Check if the current aimbot key is pressed
            if AimbotKey == Enum.UserInputType.MouseButton1 or AimbotKey == Enum.UserInputType.MouseButton2 or AimbotKey == Enum.UserInputType.MouseButton3 then
                isAimbotKeyPressed = UserInputService:IsMouseButtonPressed(AimbotKey)
            else
                -- For keyboard keys, we need to check differently
                isAimbotKeyPressed = UserInputService:IsKeyDown(Enum.KeyCode[AimbotKey.Name])
            end
            
            -- FIXED: Only aim if mouse is inside FOV circle AND holding item
            if isAimbotKeyPressed and isHoldingItem() and isMouseInFOV() then
                if not isAiming then
                    -- Just started aiming - find initial target
                    local closestTarget, distance, closestCharacter = getClosestTargetToCursor()
                    if closestTarget then
                        currentAimTarget = closestTarget
                        CurrentTarget = closestCharacter
                        updateAllHighlights()
                        isAiming = true
                    end
                end
                
                -- Continue aiming at the current target
                if currentAimTarget and currentAimTarget.Parent and isAlive(currentAimTarget.Parent) then
                    aimAtTarget(currentAimTarget)
                else
                    -- Current target is no longer valid, find new one
                    local closestTarget, distance, closestCharacter = getClosestTargetToCursor()
                    if closestTarget then
                        currentAimTarget = closestTarget
                        CurrentTarget = closestCharacter
                        updateAllHighlights()
                    else
                        currentAimTarget = nil
                        CurrentTarget = nil
                        updateAllHighlights()
                    end
                end
            else
                -- Aimbot key not pressed, not holding item, or mouse outside FOV
                if isAiming then
                    -- Just stopped aiming
                    currentAimTarget = nil
                    CurrentTarget = nil
                    updateAllHighlights()
                    isAiming = false
                end
            end
        else
            -- Aimbot disabled or text box focused
            currentAimTarget = nil
            CurrentTarget = nil
            updateAllHighlights()
            isAiming = false
        end
    end)
end

local function stopAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
        aimbotConnection = nil
    end
    currentAimTarget = nil
    CurrentTarget = nil
    isAiming = false
    updateAllHighlights()
end

-- Create Tabs
local ESPTab = Window:CreateTab("ESP", "user")
local AimbotTab = Window:CreateTab("Aimbot", "target")
local SafeZoneTab = Window:CreateTab("Safe Zone", "shield-check")
local WhitelistTab = Window:CreateTab("Whitelist", "shield")

-- ESP Tab
ESPTab:CreateSection("Player & NPC Highlighter")

-- Main Toggle
local HighlightToggle = ESPTab:CreateToggle({
    Name = "Enable Player & NPC Highlighting",
    CurrentValue = false,
    Flag = "HighlightToggle",
    Callback = function(Value)
        HighlightingEnabled = Value
        if Value then
            processExistingPlayers()
            processExistingNPCs()
            startBossMonitoring() -- Start monitoring for new bosses
            
            -- Connect to player added event
            Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function(character)
                    wait(1)
                    if player ~= LocalPlayer then
                        highlightEntity(player, character, false)
                    end
                end)
            end)
            
            -- Connect to character added events for existing players
            for _, player in pairs(Players:GetPlayers()) do
                player.CharacterAdded:Connect(function(character)
                    wait(1)
                    if player ~= LocalPlayer then
                        highlightEntity(player, character, false)
                    end
                end)
            end
            
            -- Connect to NPCs folder changes
            local npcsFolder = Workspace:FindFirstChild("NPCs")
            if npcsFolder then
                -- Regular NPCs
                npcsFolder.ChildAdded:Connect(function(npc)
                    wait(1)
                    if npc:IsA("Model") and npc.Name ~= "Boss" then
                        highlightEntity(npc, npc, true)
                    end
                end)
                
                -- Boss folder changes
                local bossFolder = npcsFolder:FindFirstChild("Boss")
                if bossFolder then
                    bossFolder.ChildAdded:Connect(function(boss)
                        wait(1)
                        if boss:IsA("Model") then
                            highlightEntity(boss, boss, true)
                        end
                    end)
                end
            end
            
            Rayfield:Notify({
                Title = "Player & NPC Highlighting",
                Content = "Highlighting has been enabled (Yourself is not highlighted)",
                Duration = 3,
                Image = 4483362458
            })
        else
            removeAllHighlights()
            stopBossMonitoring() -- Stop monitoring when highlighting is disabled
            Rayfield:Notify({
                Title = "Player & NPC Highlighting",
                Content = "Highlighting has been disabled",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Team Check Toggle
local TeamCheckToggle = ESPTab:CreateToggle({
    Name = "Team Check (Green = Teammates)",
    CurrentValue = false,
    Flag = "TeamCheckToggle",
    Callback = function(Value)
        TeamCheckEnabled = Value
        if HighlightingEnabled then
            updateAllHighlights() -- Update existing highlights instead of recreating them
        end
        local message = Value and "Team check enabled - Teammates will be green" or "Team check disabled - All players are enemies"
        Rayfield:Notify({
            Title = "Team Settings",
            Content = message,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Refresh Button
ESPTab:CreateButton({
    Name = "Refresh Players & NPCs",
    Callback = function()
        if HighlightingEnabled then
            removeAllHighlights()
            processExistingPlayers()
            processExistingNPCs()
            Rayfield:Notify({
                Title = "Player & NPC Highlighter",
                Content = "Highlights refreshed",
                Duration = 2,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Player & NPC Highlighter",
                Content = "Enable highlighting first!",
                Duration = 2,
                Image = 4483362458
            })
        end
    end,
})

-- ESP Settings Section
ESPTab:CreateSection("ESP Settings")

-- Highlight Color Picker
local HighlightColor = ESPTab:CreateColorPicker({
    Name = "Enemy Highlight Color",
    Color = Color3.fromRGB(255, 0, 0),
    Flag = "HighlightColor",
    Callback = function(Value)
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                local player = Players:GetPlayerFromCharacter(character)
                if player and player ~= LocalPlayer and character ~= CurrentTarget and not (TeamCheckEnabled and isOnSameTeam(player)) and not isPlayerWhitelisted(player) then
                    highlight.FillColor = Value
                end
            end
        end
    end
})

-- Target Highlight Color Picker
local TargetHighlightColor = ESPTab:CreateColorPicker({
    Name = "Target Highlight Color",
    Color = Color3.fromRGB(128, 0, 128),
    Flag = "TargetHighlightColor",
    Callback = function(Value)
        if CurrentTarget and ActiveHighlights[CurrentTarget] then
            ActiveHighlights[CurrentTarget].FillColor = Value
            ActiveHighlights[CurrentTarget].OutlineColor = Color3.fromRGB(200, 0, 200)
        end
    end
})

-- Teammate Highlight Color Picker
local TeammateHighlightColor = ESPTab:CreateColorPicker({
    Name = "Teammate Highlight Color",
    Color = Color3.fromRGB(0, 255, 0),
    Flag = "TeammateHighlightColor",
    Callback = function(Value)
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                local player = Players:GetPlayerFromCharacter(character)
                if player and TeamCheckEnabled and isOnSameTeam(player) then
                    highlight.FillColor = Value
                end
            end
        end
    end
})

-- Whitelist Highlight Color Picker
local WhitelistHighlightColor = ESPTab:CreateColorPicker({
    Name = "Whitelist Highlight Color",
    Color = Color3.fromRGB(0, 100, 255),
    Flag = "WhitelistHighlightColor",
    Callback = function(Value)
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                local player = Players:GetPlayerFromCharacter(character)
                if player and isPlayerWhitelisted(player) then
                    highlight.FillColor = Value
                end
            end
        end
    end
})

-- NPC Highlight Color Picker
local NPCHighlightColor = ESPTab:CreateColorPicker({
    Name = "NPC Highlight Color",
    Color = Color3.fromRGB(255, 255, 0),
    Flag = "NPCHighlightColor",
    Callback = function(Value)
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                local player = Players:GetPlayerFromCharacter(character)
                if not player then -- This is an NPC
                    highlight.FillColor = Value
                end
            end
        end
    end
})

-- Boss Highlight Color Picker
local BossHighlightColor = ESPTab:CreateColorPicker({
    Name = "Boss Highlight Color",
    Color = Color3.fromRGB(255, 0, 0),
    Flag = "BossHighlightColor",
    Callback = function(Value)
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                local isBoss = false
                local npcsFolder = Workspace:FindFirstChild("NPCs")
                if npcsFolder then
                    local bossFolder = npcsFolder:FindFirstChild("Boss")
                    if bossFolder then
                        for _, boss in pairs(bossFolder:GetChildren()) do
                            if boss == character then
                                isBoss = true
                                break
                            end
                        end
                    end
                end
                
                if isBoss then
                    highlight.FillColor = Value
                end
            end
        end
    end
})

-- Highlight Transparency Slider
local TransparencySlider = ESPTab:CreateSlider({
    Name = "Highlight Transparency",
    Range = {0, 100},
    Increment = 5,
    Suffix = "%",
    CurrentValue = 30,
    Flag = "HighlightTransparency",
    Callback = function(Value)
        local transparency = Value / 100
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                highlight.FillTransparency = transparency
            end
        end
    end,
})

-- Aimbot Tab
AimbotTab:CreateSection("Aimbot")

-- Aimbot Toggle
local AimbotToggle = AimbotTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Flag = "AimbotToggle",
    Callback = function(Value)
        AimbotEnabled = Value
        if Value then
            startAimbot()
            createFOVCircle()
            FOVCircle.Visible = true
            Rayfield:Notify({
                Title = "Aimbot",
                Content = "Aimbot enabled - Hold " .. getKeyName(AimbotKey) .. " while holding an item AND mouse inside FOV circle to aim",
                Duration = 4,
                Image = 4483362458
            })
        else
            stopAimbot()
            if FOVCircle then
                FOVCircle.Visible = false
            end
            Rayfield:Notify({
                Title = "Aimbot",
                Content = "Aimbot disabled",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Aimbot Keybind Button
KeybindButton = AimbotTab:CreateButton({
    Name = "Aimbot Key: " .. getKeyName(AimbotKey),
    Callback = function()
        startKeyListen()
    end,
})

-- Aimbot Settings
local AimbotFOVSlider = AimbotTab:CreateSlider({
    Name = "Aimbot FOV (Pixels)",
    Range = {50, 500},
    Increment = 10,
    Suffix = "px",
    CurrentValue = 200,
    Flag = "AimbotFOV",
    Callback = function(Value)
        AimbotFOV = Value
        updateFOVCircle()
        Rayfield:Notify({
            Title = "Aimbot Settings",
            Content = "Aimbot FOV set to " .. Value .. " pixels",
            Duration = 2,
            Image = 4483362458
        })
    end,
})

local AimbotSmoothnessSlider = AimbotTab:CreateSlider({
    Name = "Aimbot Smoothness",
    Range = {10, 90},
    Increment = 5,
    Suffix = "%",
    CurrentValue = 70,
    Flag = "AimbotSmoothness",
    Callback = function(Value)
        AimbotSmoothness = Value / 100
        Rayfield:Notify({
            Title = "Aimbot Settings",
            Content = "Aimbot smoothness set to " .. Value .. "%",
            Duration = 2,
            Image = 4483362458
        })
    end,
})

-- Wall Check Toggle
local WallCheckToggle = AimbotTab:CreateToggle({
    Name = "Wall Check (Recommended)",
    CurrentValue = true,
    Flag = "WallCheckToggle",
    Callback = function(Value)
        WallCheckEnabled = Value
        local message = Value and "Wall check enabled" or "Wall check disabled"
        Rayfield:Notify({
            Title = "Aimbot Settings",
            Content = message,
            Duration = 2,
            Image = 4483362458
        })
    end,
})

-- FOV Circle Toggle
local FOVCircleToggle = AimbotTab:CreateToggle({
    Name = "Show FOV Circle",
    CurrentValue = true,
    Flag = "FOVCircleToggle",
    Callback = function(Value)
        if FOVCircle then
            FOVCircle.Visible = Value
        end
        local message = Value and "FOV circle shown" or "FOV circle hidden"
        Rayfield:Notify({
            Title = "Aimbot Settings",
            Content = message,
            Duration = 2,
            Image = 4483362458
        })
    end,
})

-- Safe Zone Tab
SafeZoneTab:CreateSection("Safe Zone Platform")

-- Create Safe Zone Platform Button
SafeZoneTab:CreateButton({
    Name = "Create Safe Zone Platform",
    Callback = function()
        createSafeZonePlatform()
        Rayfield:Notify({
            Title = "Safe Zone",
            Content = "Safe Zone platform created at position (9999, 50, 9999)",
            Duration = 4,
            Image = 4483362458
        })
    end,
})

-- Teleport to Safe Zone Button
SafeZoneTab:CreateButton({
    Name = "Teleport to Safe Zone",
    Callback = function()
        teleportToSafeZone()
    end,
})

-- Teleport Back Button
SafeZoneTab:CreateButton({
    Name = "Teleport Back from Safe Zone",
    Callback = function()
        teleportBackFromSafeZone()
    end,
})

-- Info Section
SafeZoneTab:CreateSection("Safe Zone Info")

SafeZoneTab:CreateParagraph({
    Title = "Safe Zone Info",
    Content = "Create a safe zone platform at position (9999, 50, 9999) where you can teleport to avoid danger. Your original position is saved so you can teleport back. The platform is green and made of grass material."
})

-- Whitelist Tab
WhitelistTab:CreateSection("Whitelist Settings")

-- Whitelist Toggle
local WhitelistToggle = WhitelistTab:CreateToggle({
    Name = "Enable Player Whitelist",
    CurrentValue = false,
    Flag = "WhitelistToggle",
    Callback = function(Value)
        WhitelistEnabled = Value
        if HighlightingEnabled then
            updateAllHighlights()
        end
        local message = Value and "Whitelist enabled - Whitelisted players will be blue and ignored by aimbot" or "Whitelist disabled"
        Rayfield:Notify({
            Title = "Whitelist Settings",
            Content = message,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Player List Section
WhitelistTab:CreateSection("Player List")

-- Get all current players
local function getPlayerNames()
    local playerNames = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerNames, player.Name)
        end
    end
    table.sort(playerNames)
    return playerNames
end

-- Create player dropdown
local PlayerDropdown = WhitelistTab:CreateDropdown({
    Name = "Select Player",
    Options = getPlayerNames(),
    CurrentOption = {},
    MultipleOptions = false,
    Flag = "PlayerDropdown",
    Callback = function(Option)
        -- This will be used when adding players
    end,
})

-- Refresh player list button
WhitelistTab:CreateButton({
    Name = "Refresh Player List",
    Callback = function()
        PlayerDropdown:Refresh(getPlayerNames())
        Rayfield:Notify({
            Title = "Whitelist",
            Content = "Player list refreshed",
            Duration = 2,
            Image = 4483362458
        })
    end,
})

-- Whitelist Management Section
WhitelistTab:CreateSection("Whitelist Management")

-- Add player to whitelist
WhitelistTab:CreateButton({
    Name = "Add Selected Player to Whitelist",
    Callback = function()
        local selectedPlayer = PlayerDropdown.CurrentOption[1]
        if selectedPlayer then
            WhitelistedPlayers[selectedPlayer] = true
            if HighlightingEnabled then
                updateAllHighlights()
            end
            Rayfield:Notify({
                Title = "Whitelist",
                Content = "Added " .. selectedPlayer .. " to whitelist",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Whitelist Error",
                Content = "Please select a player first",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Remove player from whitelist
WhitelistTab:CreateButton({
    Name = "Remove Selected Player from Whitelist",
    Callback = function()
        local selectedPlayer = PlayerDropdown.CurrentOption[1]
        if selectedPlayer and WhitelistedPlayers[selectedPlayer] then
            WhitelistedPlayers[selectedPlayer] = nil
            if HighlightingEnabled then
                updateAllHighlights()
            end
            Rayfield:Notify({
                Title = "Whitelist",
                Content = "Removed " .. selectedPlayer .. " from whitelist",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Whitelist Error",
                Content = "Player not in whitelist or no player selected",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Clear all whitelist
WhitelistTab:CreateButton({
    Name = "Clear All Whitelisted Players",
    Callback = function()
        WhitelistedPlayers = {}
        if HighlightingEnabled then
            updateAllHighlights()
        end
        Rayfield:Notify({
            Title = "Whitelist",
            Content = "Cleared all whitelisted players",
            Duration = 3,
            Image = 4483362458
        })
    end,
})

-- Show current whitelist
WhitelistTab:CreateButton({
    Name = "Show Whitelisted Players",
    Callback = function()
        local whitelistedNames = {}
        for name, _ in pairs(WhitelistedPlayers) do
            table.insert(whitelistedNames, name)
        end
        
        if #whitelistedNames > 0 then
            table.sort(whitelistedNames)
            Rayfield:Notify({
                Title = "Whitelisted Players (" .. #whitelistedNames .. ")",
                Content = table.concat(whitelistedNames, ", "),
                Duration = 6,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Whitelisted Players",
                Content = "No players are whitelisted",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Auto-refresh player list when players join/leave
Players.PlayerAdded:Connect(function(player)
    task.wait(1) -- Wait a bit for player to fully load
    PlayerDropdown:Refresh(getPlayerNames())
end)

Players.PlayerRemoving:Connect(function(player)
    PlayerDropdown:Refresh(getPlayerNames())
end)

-- Removals Tab
local RemovalsTab = Window:CreateTab("Removals", "trash")

-- Variables for automatic removal
local AutoRemoveEyepatchUI = false
local AutoRemoveWakeUpBlur = false

-- Function to delete EyepatchUI
local function deleteEyepatchUI()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    
    if player then
        local playerGui = player:WaitForChild("PlayerGui")
        local ui = playerGui:FindFirstChild("EyepatchUI")
        if ui then
            ui:Destroy()
            return true
        end
    end
    return false
end

-- Function to delete WakeUpBlur
local function deleteWakeUpBlur()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local clientEffects = ReplicatedStorage:FindFirstChild("ClientEffects")
    if clientEffects then
        local wakeUpBlur = clientEffects:FindFirstChild("WakeUpBlur")
        if wakeUpBlur then
            wakeUpBlur:Destroy()
            return true
        end
    end
    return false
end

-- Auto-removal loop
local removalConnection
local function startAutoRemoval()
    if removalConnection then
        removalConnection:Disconnect()
    end
    
    removalConnection = RunService.Heartbeat:Connect(function()
        if AutoRemoveEyepatchUI then
            deleteEyepatchUI()
        end
        
        if AutoRemoveWakeUpBlur then
            deleteWakeUpBlur()
        end
    end)
end

local function stopAutoRemoval()
    if removalConnection then
        removalConnection:Disconnect()
        removalConnection = nil
    end
end

-- Removals Tab Content
RemovalsTab:CreateSection("Automatic UI Removal")

-- EyepatchUI Toggle
local EyepatchUIToggle = RemovalsTab:CreateToggle({
    Name = "Auto Remove EyepatchUI",
    CurrentValue = false,
    Flag = "EyepatchUIToggle",
    Callback = function(Value)
        AutoRemoveEyepatchUI = Value
        if Value then
            -- Try to delete immediately
            if deleteEyepatchUI() then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "EyepatchUI deleted and auto-removal enabled",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "EyepatchUI auto-removal enabled (not currently found)",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        else
            Rayfield:Notify({
                Title = "Removals",
                Content = "EyepatchUI auto-removal disabled",
                Duration = 3,
                Image = 4483362458
            })
        end
        
        -- Update auto-removal system
        if AutoRemoveEyepatchUI or AutoRemoveWakeUpBlur then
            startAutoRemoval()
        else
            stopAutoRemoval()
        end
    end,
})

-- WakeUpBlur Toggle
local WakeUpBlurToggle = RemovalsTab:CreateToggle({
    Name = "Auto Remove WakeUpBlur",
    CurrentValue = false,
    Flag = "WakeUpBlurToggle",
    Callback = function(Value)
        AutoRemoveWakeUpBlur = Value
        if Value then
            -- Try to delete immediately
            if deleteWakeUpBlur() then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "WakeUpBlur deleted and auto-removal enabled",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "WakeUpBlur auto-removal enabled (not currently found)",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        else
            Rayfield:Notify({
                Title = "Removals",
                Content = "WakeUpBlur auto-removal disabled",
                Duration = 3,
                Image = 4483362458
            })
        end
        
        -- Update auto-removal system
        if AutoRemoveEyepatchUI or AutoRemoveWakeUpBlur then
            startAutoRemoval()
        else
            stopAutoRemoval()
        end
    end,
})

-- Manual Removal Section
RemovalsTab:CreateSection("Manual Removal")

-- Manual EyepatchUI Removal Button
RemovalsTab:CreateButton({
    Name = "Delete EyepatchUI Now",
    Callback = function()
        if deleteEyepatchUI() then
            Rayfield:Notify({
                Title = "Removals",
                Content = "EyepatchUI deleted successfully!",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Removals",
                Content = "EyepatchUI not found",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Manual WakeUpBlur Removal Button
RemovalsTab:CreateButton({
    Name = "Delete WakeUpBlur Now",
    Callback = function()
        if deleteWakeUpBlur() then
            Rayfield:Notify({
                Title = "Removals",
                Content = "WakeUpBlur deleted successfully!",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Removals",
                Content = "WakeUpBlur not found",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Delete Both Button
RemovalsTab:CreateButton({
    Name = "Delete Both Now",
    Callback = function()
        local deletedEyepatch = deleteEyepatchUI()
        local deletedWakeUp = deleteWakeUpBlur()
        
        if deletedEyepatch and deletedWakeUp then
            Rayfield:Notify({
                Title = "Removals",
                Content = "Both EyepatchUI and WakeUpBlur deleted!",
                Duration = 3,
                Image = 4483362458
            })
        elseif deletedEyepatch then
            Rayfield:Notify({
                Title = "Removals",
                Content = "EyepatchUI deleted (WakeUpBlur not found)",
                Duration = 3,
                Image = 4483362458
            })
        elseif deletedWakeUp then
            Rayfield:Notify({
                Title = "Removals",
                Content = "WakeUpBlur deleted (EyepatchUI not found)",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Removals",
                Content = "Neither EyepatchUI nor WakeUpBlur found",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Info Section
RemovalsTab:CreateSection("Removal Info")

RemovalsTab:CreateParagraph({
    Title = "Automatic Removal Features",
    Content = "Enable the toggles above to automatically delete EyepatchUI and WakeUpBlur. The system will continuously check and remove these elements as soon as they appear. Use the manual buttons for immediate removal."
})

-- Load configuration
Rayfield:LoadConfiguration()

-- Create FOV circle on startup
createFOVCircle()
FOVCircle.Visible = false

-- Setup key listener
setupKeyListener()

-- Auto-create safe zone platform when script starts
createSafeZonePlatform()

print("Player & NPC Highlighter with Aimbot and Safe Zone Loaded!")

loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
