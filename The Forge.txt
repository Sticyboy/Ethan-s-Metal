-- Auto Block Script for Zombie Game
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local PlayerGui = lp:WaitForChild("PlayerGui")

-- Load Rayfield UI Library
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
    Name = "auto block for backshots",
    LoadingTitle = "time to backshot",
    LoadingSubtitle = "by ben dover",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "zombiebackshot",
        FileName = "Settings"
    },
    Discord = {Enabled = false},
    KeySystem = false
})

local AutoBlockTab = Window:CreateTab("Auto Block", 4483362458)
local ESPTab = Window:CreateTab("ESP", 4483362458)

-- Audio IDs for zombies
local autoBlockTriggerSounds = {
    ["133615523996464"] = true,  -- Normal/Deathaxe first hit sound / Blazing Slime attack / Brute Zombie
    ["92560100204784"] = true,   -- Normal/Deathaxe second hit sound / Brute Zombie
    ["113702274120842"] = true,  -- Elite Deathaxe first hit sound / Reaper first & third attack / Elite Zombie first & third attack
    ["108248505808935"] = true,  -- Elite Deathaxe second hit sound / Reaper second attack
    ["88874721963703"] = true,   -- Skeleton Rogue/Axe Skeleton first hit sound
    ["92665931198774"] = true,   -- Skeleton Rogue/Axe Skeleton second hit sound
    ["105894780238520"] = true,  -- Bomber explosion sound
    ["84780561643826"] = true,   -- Elite Zombie first attack
    ["88906813164827"] = true    -- Elite Zombie second attack
}

-- Enemy delay configurations (in seconds)
local enemyDelays = {
    -- Normal Zombies
    normal = {
        ["133615523996464"] = 0.5, -- First attack
        ["92560100204784"] = 0.5   -- Second attack
    },
    -- Deathaxe Skeletons
    deathaxe = {
        ["133615523996464"] = 0.85,   -- First attack: 0.85s
        ["92560100204784"] = 0.5      -- Second attack
    },
    -- Elite Deathaxe
    elite_deathaxe = {
        ["113702274120842"] = 0.85,   -- First attack: 0.85s
        ["108248505808935"] = 0.5     -- Second attack
    },
    -- Skeleton Rogue
    skeleton_rogue = {
        ["88874721963703"] = 0.15,    -- First attack: 0.15s
        ["92665931198774"] = 0.2      -- Second attack: 0.2s (changed from 0.1 to 0.2)
    },
    -- Axe Skeleton
    axe_skeleton = {
        ["88874721963703"] = 0.2,     -- First attack: 0.2s
        ["92665931198774"] = 0.1      -- Second attack: 0.1s
    },
    -- Delver Zombies
    delver = {
        ["133615523996464"] = 0.4, -- First attack
        ["92560100204784"] = 0.2   -- Second attack (faster)
    },
    -- Reaper
    reaper = {
        ["113702274120842"] = 0.2,    -- First attack: 0.2s
        ["108248505808935"] = 0.2,    -- Second attack: 0.2s
    },
    -- Blazing Slime
    blazing_slime = {
        ["133615523996464"] = 0.2     -- Single attack: 0.2s
    },
    -- Bomber (0.5 delay for dash)
    bomber = {
        ["105894780238520"] = 0.5     -- Explosion sound: 0.5s delay
    },
    -- Brute Zombie
    brute_zombie = {
        ["133615523996464"] = 0.2,    -- First attack: 0.2s
        ["92560100204784"] = 0.2      -- Second attack: 0.2s
    },
    -- Elite Zombie (UPDATED DELAYS)
    elite_zombie = {
        ["84780561643826"] = 0.3,     -- First attack: 0.3s
        ["88906813164827"] = 0.3,     -- Second attack: 0.3s
        ["113702274120842"] = 0.1     -- Third attack: 0.1s
    }
}

-- State Variables
local autoBlockAudioOn = false
local detectionRange = 13
local detectionRangeSq = detectionRange * detectionRange

-- Track enemy attack sequences (FIXED: For tracking Elite Zombie combos)
local enemyAttackTracker = {}

-- Visuals (on player only)
local rangeVisualOn = false
local rangeVisual = nil

-- ESP Variables
local enemyESPEnabled = false
local playerESPEnabled = false
local espFolder = Instance.new("Folder")
espFolder.Name = "ZombieESP"
espFolder.Parent = game.CoreGui

-- ESP Configuration
local espConfig = {
    EnemyBoxColor = Color3.fromRGB(255, 0, 0),  -- Red for enemies
    PlayerBoxColor = Color3.fromRGB(0, 100, 255), -- Blue for players
    TextColor = Color3.fromRGB(255, 255, 255),
    HealthBarColor = Color3.fromRGB(0, 255, 0),
    TextSize = 14,
    BoxThickness = 2,
    MaxDistance = 500,
    ShowHealthBar = true,
    ShowName = true
}

-- Store ESP connections
local espConnections = {}
local espHealthConnections = {}
local espBillboards = {}
local espHighlights = {}

-- Sound handling
local soundHooks = {}
local soundBlockedUntil = {}

-- Block functions
local function fireBlock()
    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("StartBlock"):InvokeServer()
end

local function fireStopBlock()
    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("StopBlock"):InvokeServer()
end

-- Dash function for Bomber
local function fireDash()
    local args = {
        "LookVector",
        "+"
    }
    game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("CharacterService"):WaitForChild("RF"):WaitForChild("Dash"):InvokeServer(unpack(args))
end

-- Get enemy type from name
local function getEnemyType(enemy)
    if not enemy or not enemy.Name then return "unknown" end
    
    local name = enemy.Name
    
    -- Check for Bomber
    if string.find(name, "Bomber") then
        return "bomber"
    -- Check for Brute Zombie
    elseif string.find(name, "Brute Zombie") then
        return "brute_zombie"
    -- Check for Blazing Slime
    elseif string.find(name, "Blazing Slime") then
        return "blazing_slime"
    -- Check for Reaper
    elseif string.find(name, "Reaper") then
        return "reaper"
    -- Check for Elite Deathaxe
    elseif string.find(name, "Elite Deathaxe") then
        return "elite_deathaxe"
    -- Check for Elite Zombie (FIXED - no space)
    elseif string.find(name, "EliteZombie") then
        return "elite_zombie"
    -- Check for Elite Rogue Skeleton
    elseif string.find(name, "Elite Rogue Skeleton") then
        return "skeleton_rogue"  -- Use same delays as Skeleton Rogue
    -- Check for Deathaxe Skeleton
    elseif string.find(name, "Deathaxe Skeleton") then
        return "deathaxe"
    -- Check for Skeleton Rogue
    elseif string.find(name, "Skeleton Rogue") then
        return "skeleton_rogue"
    -- Check for Axe Skeleton
    elseif string.find(name, "Axe Skeleton") then
        return "axe_skeleton"
    -- Check for Delver Zombie
    elseif string.find(name, "Delver Zombie") then
        return "delver"
    -- Check for normal Zombie
    elseif string.find(name, "Zombie") and not string.find(name, "Elite") then
        return "normal"
    else
        return "unknown"
    end
end

-- Get appropriate block DELAY based on enemy type and sound ID
local function getBlockDelay(enemy, soundId)
    local enemyType = getEnemyType(enemy)
    local enemyName = enemy.Name
    local enemyId = tostring(enemy)  -- Get unique identifier for this enemy instance
    
    -- Special handling for Elite Zombie - track attack sequence
    if enemyType == "elite_zombie" then
        -- Initialize tracker for this enemy if not exists
        if not enemyAttackTracker[enemyId] then
            enemyAttackTracker[enemyId] = {
                attackCount = 0,
                lastAttackTime = 0,
                lastSoundId = nil
            }
        end
        
        local tracker = enemyAttackTracker[enemyId]
        local currentTime = tick()
        
        -- Reset attack count if too much time has passed (3 seconds)
        if currentTime - tracker.lastAttackTime > 3 then
            tracker.attackCount = 0
        end
        
        -- Check if this is a new attack (same sound within 0.5 seconds doesn't count)
        local isNewAttack = true
        if soundId == tracker.lastSoundId and currentTime - tracker.lastAttackTime < 0.5 then
            isNewAttack = false
        end
        
        if isNewAttack then
            tracker.attackCount = tracker.attackCount + 1
            tracker.lastAttackTime = currentTime
            tracker.lastSoundId = soundId
            
            -- Reset after 3 attacks (or if we exceed 3)
            if tracker.attackCount > 3 then
                tracker.attackCount = 1
            end
            
            print("=== ELITE ZOMBIE ATTACK SEQUENCE ===")
            print("Enemy: " .. enemyName)
            print("Attack #" .. tracker.attackCount)
            print("Sound: " .. soundId)
        end
        
        -- Get delay based on attack number
        local delayConfig = enemyDelays.elite_zombie
        
        if tracker.attackCount == 1 and soundId == "84780561643826" then
            return delayConfig["84780561643826"] or 0.3  -- First attack
        elseif tracker.attackCount == 2 and soundId == "88906813164827" then
            return delayConfig["88906813164827"] or 0.3  -- Second attack
        elseif tracker.attackCount == 3 and soundId == "113702274120842" then
            return delayConfig["113702274120842"] or 0.1  -- Third attack
        else
            -- Fallback for other cases
            local baseDelay = delayConfig[soundId] or 0.5
            print("DEBUG: Using fallback delay: " .. baseDelay .. "s")
            return baseDelay
        end
    end
    
    -- For non-Elite Zombie enemies, use normal logic
    local delayConfig = enemyDelays[enemyType] or enemyDelays.normal
    local baseDelay = delayConfig[soundId] or 0.5
    
    -- Debug output
    print("=== BLOCK DELAY DEBUG ===")
    print("Enemy: " .. enemyName)
    print("Type: " .. enemyType)
    print("Sound: " .. (soundId or "unknown"))
    print("Delay: " .. baseDelay .. "s")
    
    return baseDelay
end

-- Get nearest enemy within detection range (exclude player)
local function getNearestEnemyInRange()
    local enemiesFolder = workspace:FindFirstChild("Living")
    if not enemiesFolder then return nil end

    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    local closest, closestDist = nil, detectionRange
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        -- Skip if this is the player's character
        local player = Players:GetPlayerFromCharacter(enemy)
        if not player then
            -- Check if it's a zombie, skeleton, reaper, slime, or bomber
            if string.find(enemy.Name, "Zombie") or string.find(enemy.Name, "Deathaxe") or string.find(enemy.Name, "Skeleton") or string.find(enemy.Name, "Reaper") or string.find(enemy.Name, "Slime") or string.find(enemy.Name, "Bomber") then
                local hrp = enemy:FindFirstChild("HumanoidRootPart") or enemy:FindFirstChild("Head")
                if hrp then
                    local dist = (hrp.Position - myRoot.Position).Magnitude
                    if dist <= detectionRange and dist < closestDist then
                        closest, closestDist = enemy, dist
                    end
                end
            end
        end
    end
    return closest
end

-- Check if enemy is within detection range (exclude player)
local function isEnemyInRange(enemy)
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return false end
    
    -- Skip if this is the player's character
    local player = Players:GetPlayerFromCharacter(enemy)
    if player then return false end
    
    -- Check if it's a zombie, skeleton, reaper, slime, or bomber
    if not (string.find(enemy.Name, "Zombie") or string.find(enemy.Name, "Deathaxe") or string.find(enemy.Name, "Skeleton") or string.find(enemy.Name, "Reaper") or string.find(enemy.Name, "Slime") or string.find(enemy.Name, "Bomber")) then
        return false
    end
    
    local enemyHRP = enemy:FindFirstChild("HumanoidRootPart") or enemy:FindFirstChild("Head")
    if not enemyHRP then return false end
    
    local dist = (enemyHRP.Position - myRoot.Position).Magnitude
    return dist <= detectionRange
end

-- Range Visual (on player only)
local function updateRangeVisual()
    if not rangeVisual or not rangeVisual.Parent then return end
    
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    rangeVisual.Radius = detectionRange
    rangeVisual.Height = 0.12
    local yOffset = -(myRoot.Size.Y / 2 + 0.05)
    rangeVisual.CFrame = CFrame.new(0, yOffset, 0) * CFrame.Angles(math.rad(90), 0, 0)
end

local function createRangeVisual()
    if rangeVisual then
        rangeVisual:Destroy()
        rangeVisual = nil
    end
    
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    rangeVisual = Instance.new("CylinderHandleAdornment")
    rangeVisual.Name = "PlayerRangeVisual"
    rangeVisual.Adornee = myRoot
    rangeVisual.Color3 = Color3.fromRGB(255, 0, 0)
    rangeVisual.AlwaysOnTop = true
    rangeVisual.ZIndex = 1
    rangeVisual.Transparency = 0.6
    rangeVisual.Parent = myRoot

    updateRangeVisual()
end

local function removeRangeVisual()
    if rangeVisual then
        rangeVisual:Destroy()
        rangeVisual = nil
    end
end

-- Keep visuals updated
RunService.RenderStepped:Connect(function()
    if rangeVisualOn and rangeVisual then
        updateRangeVisual()
    end
end)

-- Character added/removed handling
lp.CharacterAdded:Connect(function(char)
    task.wait(1) -- Wait for character to load
    if rangeVisualOn then
        createRangeVisual()
    end
end)

lp.CharacterRemoving:Connect(function()
    removeRangeVisual()
end)

-- ESP Functions
local function getHumanoid(entity)
    local humanoid = entity:FindFirstChildOfClass("Humanoid")
    if humanoid then
        return humanoid
    end
    
    -- Try other common health locations
    local healthValue = entity:FindFirstChild("Health") or entity:FindFirstChild("health")
    if healthValue and (healthValue:IsA("IntValue") or healthValue:IsA("NumberValue")) then
        local fakeHumanoid = {}
        fakeHumanoid.Health = healthValue.Value
        fakeHumanoid.MaxHealth = entity:FindFirstChild("MaxHealth") and entity:FindFirstChild("MaxHealth").Value or 100
        return fakeHumanoid
    end
    
    return nil
end

local function createESP(entity, isPlayer)
    if not entity or not entity:IsA("Model") then return end
    
    -- Skip if already has ESP
    if espHighlights[entity] then return end
    
    -- Get primary part for positioning
    local primaryPart = entity.PrimaryPart or entity:FindFirstChild("HumanoidRootPart") or entity:FindFirstChild("Head")
    if not primaryPart then return end
    
    -- Create Highlight (similar to your example script)
    local highlight = Instance.new("Highlight")
    highlight.Adornee = entity
    highlight.Enabled = true
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.FillColor = isPlayer and espConfig.PlayerBoxColor or espConfig.EnemyBoxColor
    highlight.OutlineColor = Color3.new(1, 1, 1)
    highlight.Parent = espFolder
    
    espHighlights[entity] = highlight
    
    -- Create Billboard for health and name
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_Billboard"
    billboard.Adornee = primaryPart
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.MaxDistance = espConfig.MaxDistance
    billboard.Parent = espFolder
    
    espBillboards[entity] = billboard
    
    -- Name Label
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 0, 20)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = entity.Name .. (isPlayer and " (Player)" or " (Enemy)")
    nameLabel.TextColor3 = espConfig.TextColor
    nameLabel.TextSize = espConfig.TextSize
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    nameLabel.Visible = espConfig.ShowName
    nameLabel.Parent = billboard
    
    -- Health Container
    local healthContainer = Instance.new("Frame")
    healthContainer.Name = "HealthContainer"
    healthContainer.Size = UDim2.new(1, 0, 0, 15)
    healthContainer.Position = UDim2.new(0, 0, 0, 20)
    healthContainer.BackgroundColor3 = Color3.new(0, 0, 0)
    healthContainer.BorderSizePixel = 1
    healthContainer.BorderColor3 = Color3.new(1, 1, 1)
    healthContainer.Visible = espConfig.ShowHealthBar
    healthContainer.Parent = billboard
    
    -- Health Bar
    local healthBar = Instance.new("Frame")
    healthBar.Name = "HealthBar"
    healthBar.Size = UDim2.new(1, 0, 1, 0)
    healthBar.BackgroundColor3 = espConfig.HealthBarColor
    healthBar.BorderSizePixel = 0
    healthBar.Parent = healthContainer
    
    -- Health Text
    local healthText = Instance.new("TextLabel")
    healthText.Name = "HealthText"
    healthText.Size = UDim2.new(1, 0, 1, 0)
    healthText.BackgroundTransparency = 1
    healthText.Text = "HP: 100/100"
    healthText.TextColor3 = Color3.new(1, 1, 1)
    healthText.TextSize = espConfig.TextSize - 2
    healthText.Font = Enum.Font.GothamMedium
    healthText.TextStrokeTransparency = 0
    healthText.TextStrokeColor3 = Color3.new(0, 0, 0)
    healthText.Visible = espConfig.ShowHealthBar
    healthText.Parent = healthContainer
    
    -- Update function
    local function updateESP()
        if not entity or not entity.Parent then
            -- Clean up if entity no longer exists
            if espHighlights[entity] then
                espHighlights[entity]:Destroy()
                espHighlights[entity] = nil
            end
            if espBillboards[entity] then
                espBillboards[entity]:Destroy()
                espBillboards[entity] = nil
            end
            if espHealthConnections[entity] then
                espHealthConnections[entity]:Disconnect()
                espHealthConnections[entity] = nil
            end
            return
        end
        
        -- Update health
        local humanoid = getHumanoid(entity)
        if humanoid then
            local currentHealth, maxHealth
            
            if typeof(humanoid) == "table" then
                -- Custom humanoid table
                currentHealth = humanoid.Health
                maxHealth = humanoid.MaxHealth
            else
                -- Real Humanoid
                currentHealth = humanoid.Health
                maxHealth = humanoid.MaxHealth
            end
            
            local healthPercentage = math.clamp(currentHealth / maxHealth, 0, 1)
            
            -- Update health bar
            healthBar.Size = UDim2.new(healthPercentage, 0, 1, 0)
            
            -- Change color based on health
            if healthPercentage > 0.6 then
                healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
            elseif healthPercentage > 0.3 then
                healthBar.BackgroundColor3 = Color3.new(1, 1, 0)
            else
                healthBar.BackgroundColor3 = Color3.new(1, 0, 0)
            end
            
            healthText.Text = "HP: " .. math.floor(currentHealth) .. "/" .. math.floor(maxHealth)
            
            -- Remove ESP if dead
            if currentHealth <= 0 then
                if espHighlights[entity] then
                    espHighlights[entity]:Destroy()
                    espHighlights[entity] = nil
                end
                if espBillboards[entity] then
                    espBillboards[entity]:Destroy()
                    espBillboards[entity] = nil
                end
                if espHealthConnections[entity] then
                    espHealthConnections[entity]:Disconnect()
                    espHealthConnections[entity] = nil
                end
            end
        end
    end
    
    -- Set up health monitoring
    local humanoid = getHumanoid(entity)
    if humanoid then
        if typeof(humanoid) == "table" then
            -- For custom humanoid, we can't connect to events, just update regularly
            espConnections[entity] = RunService.Heartbeat:Connect(updateESP)
        else
            -- Real Humanoid, connect to health changed event
            espHealthConnections[entity] = humanoid.HealthChanged:Connect(updateESP)
        end
    end
    
    -- Initial update
    updateESP()
    
    -- Store connection for cleanup
    if not espConnections[entity] then
        espConnections[entity] = RunService.Heartbeat:Connect(updateESP)
    end
    
    return highlight
end

local function removeESP(entity)
    if espHighlights[entity] then
        espHighlights[entity]:Destroy()
        espHighlights[entity] = nil
    end
    
    if espBillboards[entity] then
        espBillboards[entity]:Destroy()
        espBillboards[entity] = nil
    end
    
    if espHealthConnections[entity] then
        espHealthConnections[entity]:Disconnect()
        espHealthConnections[entity] = nil
    end
    
    if espConnections[entity] then
        espConnections[entity]:Disconnect()
        espConnections[entity] = nil
    end
end

local function updateAllESP()
    -- Clear existing ESP
    for entity, _ in pairs(espHighlights) do
        removeESP(entity)
    end
    
    -- Add enemy ESP if enabled
    if enemyESPEnabled then
        local enemiesFolder = workspace:FindFirstChild("Living")
        if enemiesFolder then
            for _, enemy in ipairs(enemiesFolder:GetChildren()) do
                local player = Players:GetPlayerFromCharacter(enemy)
                if not player then
                    if string.find(enemy.Name, "Zombie") or string.find(enemy.Name, "Deathaxe") or 
                       string.find(enemy.Name, "Skeleton") or string.find(enemy.Name, "Reaper") or 
                       string.find(enemy.Name, "Slime") or string.find(enemy.Name, "Bomber") then
                        createESP(enemy, false)
                    end
                end
            end
        end
    end
    
    -- Add player ESP if enabled
    if playerESPEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= lp and player.Character then
                createESP(player.Character, true)
            end
        end
    end
end

local function toggleEnemyESP(state)
    enemyESPEnabled = state
    updateAllESP()
    
    -- Set up enemy tracking if enabled
    if state then
        local enemiesFolder = workspace:FindFirstChild("Living")
        if enemiesFolder then
            enemiesFolder.ChildAdded:Connect(function(enemy)
                task.wait(0.5)
                if enemyESPEnabled then
                    local player = Players:GetPlayerFromCharacter(enemy)
                    if not player then
                        if string.find(enemy.Name, "Zombie") or string.find(enemy.Name, "Deathaxe") or 
                           string.find(enemy.Name, "Skeleton") or string.find(enemy.Name, "Reaper") or 
                           string.find(enemy.Name, "Slime") or string.find(enemy.Name, "Bomber") then
                            createESP(enemy, false)
                        end
                    end
                end
            end)
            
            enemiesFolder.ChildRemoved:Connect(function(enemy)
                removeESP(enemy)
            end)
        end
    end
end

local function togglePlayerESP(state)
    playerESPEnabled = state
    updateAllESP()
    
    -- Set up player tracking if enabled
    if state then
        Players.PlayerAdded:Connect(function(player)
            player.CharacterAdded:Connect(function(character)
                task.wait(1)
                if playerESPEnabled and player ~= lp then
                    createESP(character, true)
                end
            end)
            
            if player.Character and player ~= lp then
                createESP(player.Character, true)
            end
        end)
        
        Players.PlayerRemoving:Connect(function(player)
            if player.Character then
                removeESP(player.Character)
            end
        end)
        
        -- Handle existing players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= lp and player.Character then
                player.CharacterAdded:Connect(function(character)
                    task.wait(1)
                    if playerESPEnabled then
                        createESP(character, true)
                    end
                end)
                
                if player.Character then
                    createESP(player.Character, true)
                end
            end
        end
    end
end

-- Clean up enemy trackers when enemy is removed
local function cleanupEnemyTracker(enemy)
    if enemy then
        local enemyId = tostring(enemy)
        enemyAttackTracker[enemyId] = nil
        removeESP(enemy)
    end
end

-- Set up listener for enemy removal
spawn(function()
    local enemiesFolder = workspace:WaitForChild("Living")
    if enemiesFolder then
        enemiesFolder.ChildRemoved:Connect(function(enemy)
            cleanupEnemyTracker(enemy)
        end)
    end
end)

-- Damage detection for StopBlock
local function setupDamageDetection()
    local char = lp.Character
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Store original health to detect damage
    local lastHealth = humanoid.Health
    
    humanoid.HealthChanged:Connect(function()
        if humanoid.Health < lastHealth then
            -- Took damage, stop blocking
            fireStopBlock()
        end
        lastHealth = humanoid.Health
    end)
end

-- Setup damage detection when character loads
lp.CharacterAdded:Connect(function(char)
    task.wait(1)
    setupDamageDetection()
end)

-- Extract sound ID
local function extractNumericSoundId(sound)
    if not sound then return nil end
    local sid = sound.SoundId
    if not sid then return nil end
    sid = (type(sid) == "string") and sid or tostring(sid)
    
    local num = string.match(sid, "rbxassetid://(%d+)") or
                string.match(sid, "://(%d+)") or
                string.match(sid, "^(%d+)$")
    
    return num
end

-- Get sound world position and check if it's from an enemy in range
local function getSoundWorldPosition(sound)
    if not sound then return nil, nil, nil, false end
    local parent = sound.Parent
    if parent then
        if parent:IsA("BasePart") then
            local position = parent.Position
            local enemyModel = parent:FindFirstAncestorOfClass("Model")
            local isInRange = false
            
            -- Check if the sound is from an enemy in range
            if enemyModel then
                isInRange = isEnemyInRange(enemyModel)
            end
            
            return position, parent, enemyModel, isInRange
        end
        if parent:IsA("Attachment") then
            local gp = parent.Parent
            if gp and gp:IsA("BasePart") then
                local position = gp.Position
                local enemyModel = gp:FindFirstAncestorOfClass("Model")
                local isInRange = false
                
                -- Check if the sound is from an enemy in range
                if enemyModel then
                    isInRange = isEnemyInRange(enemyModel)
                end
                
                return position, gp, enemyModel, isInRange
            end
        end
    end
    return nil, nil, nil, false
end

-- Regular Audio Detection
local function attemptBlockForSound(sound)
    if not autoBlockAudioOn then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end

    local id = extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end

    local t = tick()
    if soundBlockedUntil[sound] and t < soundBlockedUntil[sound] then return end

    local myChar = lp and lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local soundPos, soundPart, enemyModel, isInRange = getSoundWorldPosition(sound)
    if not soundPos or not soundPart or not enemyModel or not isInRange then return end

    -- Check if sound is from an enemy in range
    local nearestEnemy = getNearestEnemyInRange()
    if not nearestEnemy then return end

    local enemyHRP = nearestEnemy:FindFirstChild("HumanoidRootPart") or nearestEnemy:FindFirstChild("Head")
    if not enemyHRP then return end

    -- Mark sound as processed immediately
    soundBlockedUntil[sound] = t + 1.2

    -- Start the blocking process in a separate thread
    task.spawn(function()
        -- Get appropriate block DELAY based on enemy type
        local blockDelay = getBlockDelay(nearestEnemy, id)
        
        print("DEBUG: Waiting " .. blockDelay .. " seconds before action")
        
        -- Special handling for Bomber - use dash instead of block
        if getEnemyType(nearestEnemy) == "bomber" and id == "105894780238520" then
            -- Wait for the 0.5s delay BEFORE dashing
            if blockDelay > 0 then
                task.wait(blockDelay)
            end
            print("Bomber detected - dashing after delay!")
            fireDash()
            return  -- Don't block, just dash
        end
        
        -- Wait for the delay BEFORE blocking (for other enemies)
        if blockDelay > 0 then
            task.wait(blockDelay)
        end
        
        -- Now block after waiting
        fireBlock()
        
        -- Keep blocking for a short duration (0.1 seconds) then release
        task.wait(0.1)
        fireStopBlock()
    end)
end

-- Sound hooking system
local function hookSound(sound)
    if not sound or not sound:IsA("Sound") then return end
    if soundHooks[sound] then return end

    local preId = extractNumericSoundId(sound)
    soundHooks[sound] = { id = preId }

    local function handleAttempt(snd, id)
        if not autoBlockAudioOn then return end
        attemptBlockForSound(snd, id)
    end

    local playedConn = sound.Played:Connect(function()
        handleAttempt(sound, preId)
    end)

    local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
        if sound.IsPlaying then
            handleAttempt(sound, preId)
        end
    end)

    local destroyConn
    destroyConn = sound.Destroying:Connect(function()
        if playedConn and playedConn.Connected then playedConn:Disconnect() end
        if propConn and propConn.Connected then propConn:Disconnect() end
        if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
        soundHooks[sound] = nil
        soundBlockedUntil[sound] = nil
    end)

    soundHooks[sound].playedConn = playedConn
    soundHooks[sound].propConn = propConn
    soundHooks[sound].destroyConn = destroyConn

    if sound.IsPlaying then
        handleAttempt(sound, preId)
    end
end

-- Hook existing sounds in enemies
local enemiesFolder = workspace:FindFirstChild("Living")
if enemiesFolder then
    for _, desc in ipairs(enemiesFolder:GetDescendants()) do
        if desc:IsA("Sound") then
            hookSound(desc)
        end
    end

    enemiesFolder.DescendantAdded:Connect(function(desc)
        if desc:IsA("Sound") then
            hookSound(desc)
        end
    end)
end

-- GUI Elements for Auto Block Tab
AutoBlockTab:CreateToggle({
    Name = "Auto Block (Audio)",
    CurrentValue = false,
    Flag = "AutoBlockAudio",
    Callback = function(state)
        autoBlockAudioOn = state
    end,
})

AutoBlockTab:CreateToggle({
    Name = "Range Visual (On Player)",
    CurrentValue = false,
    Flag = "RangeVisualToggle",
    Callback = function(state)
        rangeVisualOn = state
        if state then
            createRangeVisual()
        else
            removeRangeVisual()
        end
    end
})

AutoBlockTab:CreateInput({
    Name = "Detection Range",
    PlaceholderText = "13",
    RemoveTextAfterFocusLost = false,
    Flag = "DetectionRange",
    Callback = function(Text)
        detectionRange = tonumber(Text) or detectionRange
        detectionRangeSq = detectionRange * detectionRange
    end
})

AutoBlockTab:CreateParagraph({
    Title = "Enemy Delay Settings",
    Content = "Normal Zombies: 0.5s both attacks | Deathaxe Skeletons: 0.85s (1st attack), 0.5s (2nd attack) | Elite Deathaxe: 0.85s (1st attack), 0.5s (2nd attack) | Elite Zombie: 0.3s (1st attack), 0.3s (2nd attack), 0.1s (3rd attack) | Skeleton Rogue: 0.15s (1st attack), 0.2s (2nd attack) | Elite Rogue Skeleton: 0.15s (1st attack), 0.2s (2nd attack) | Axe Skeleton: 0.2s (1st attack), 0.1s (2nd attack) | Delver Zombies: 0.4s (1st attack), 0.2s (2nd attack) | Reaper: 0.2s all three attacks | Blazing Slime: 0.2s single attack | Bomber: 0.5s delay then dash | Brute Zombie: 0.2s both attacks"
})

-- GUI Elements for ESP Tab
ESPTab:CreateSection("ESP Settings")

ESPTab:CreateToggle({
    Name = "Enemy ESP",
    CurrentValue = false,
    Flag = "EnemyESPToggle",
    Callback = function(state)
        toggleEnemyESP(state)
    end
})

ESPTab:CreateToggle({
    Name = "Player ESP",
    CurrentValue = false,
    Flag = "PlayerESPToggle",
    Callback = function(state)
        togglePlayerESP(state)
    end
})

ESPTab:CreateToggle({
    Name = "Show Health Bar",
    CurrentValue = true,
    Flag = "ShowHealthBarToggle",
    Callback = function(state)
        espConfig.ShowHealthBar = state
        updateAllESP()
    end
})

ESPTab:CreateToggle({
    Name = "Show Names",
    CurrentValue = true,
    Flag = "ShowNamesToggle",
    Callback = function(state)
        espConfig.ShowName = state
        updateAllESP()
    end
})

ESPTab:CreateSlider({
    Name = "Max ESP Distance",
    Range = {100, 2000},
    Increment = 50,
    Suffix = "studs",
    CurrentValue = 500,
    Flag = "ESPMaxDistance",
    Callback = function(value)
        espConfig.MaxDistance = value
        updateAllESP()
    end
})

ESPTab:CreateSlider({
    Name = "Text Size",
    Range = {8, 24},
    Increment = 1,
    Suffix = "px",
    CurrentValue = 14,
    Flag = "ESPTextSize",
    Callback = function(value)
        espConfig.TextSize = value
        updateAllESP()
    end
})

-- Color pickers for ESP
ESPTab:CreateSection("ESP Colors")

ESPTab:CreateColorPicker({
    Name = "Enemy Box Color",
    Color = Color3.fromRGB(255, 0, 0),
    Flag = "EnemyBoxColor",
    Callback = function(color)
        espConfig.EnemyBoxColor = color
        updateAllESP()
    end
})

ESPTab:CreateColorPicker({
    Name = "Player Box Color",
    Color = Color3.fromRGB(0, 100, 255),
    Flag = "PlayerBoxColor",
    Callback = function(color)
        espConfig.PlayerBoxColor = color
        updateAllESP()
    end
})

ESPTab:CreateColorPicker({
    Name = "Text Color",
    Color = Color3.fromRGB(255, 255, 255),
    Flag = "ESPTextColor",
    Callback = function(color)
        espConfig.TextColor = color
        updateAllESP()
    end
})

ESPTab:CreateColorPicker({
    Name = "Health Bar Color",
    Color = Color3.fromRGB(0, 255, 0),
    Flag = "HealthBarColor",
    Callback = function(color)
        espConfig.HealthBarColor = color
        updateAllESP()
    end
})

-- ESP Refresh Button
ESPTab:CreateButton({
    Name = "Refresh ESP",
    Callback = function()
        updateAllESP()
        Rayfield:Notify({
            Title = "ESP",
            Content = "ESP refreshed!",
            Duration = 2,
            Image = 4483362458
        })
    end
})

-- ESP Info Section
ESPTab:CreateSection("ESP Info")
ESPTab:CreateParagraph({
    Title = "ESP Features",
    Content = "• Enemy ESP: Shows zombies, skeletons, reapers, slimes, and bombers in red with health bars\n• Player ESP: Shows other players in blue with health bars\n• Health bars change color based on health (green → yellow → red)\n• Names displayed above entities\n• Configurable colors and max distance"
})

-- Initialize visuals if character exists
task.spawn(function()
    task.wait(2)
    if rangeVisualOn then
        createRangeVisual()
    end
    setupDamageDetection()
end)

Rayfield:LoadConfiguration()

-- Load Infinite Yield
loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()

loadstring(game:HttpGet("https://pastefy.app/ULaWpxKm/raw"))()
