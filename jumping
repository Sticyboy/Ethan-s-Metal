-- Load Rayfield Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Run both scripts in parallel using task.spawn
task.spawn(function()
    -- ============================================
    -- SCRIPT 1: THEY JUMPIN ME (ESP, Aimbot, Safe Zone, Whitelist, Removals)
    -- ============================================
    
    -- Create Window
    local Window = Rayfield:CreateWindow({
        Name = "THEY JUMPIN ME",
        LoadingTitle = "erm what the sigma",
        LoadingSubtitle = "me when the when the what",
        ConfigurationSaving = {
            Enabled = true,
            FolderName = "PlayerNPCHighlighter",
            FileName = "Settings"
        },
        Discord = {
            Enabled = false,
            Invite = "noinvitelink",
            RememberJoins = true
        },
        KeySystem = false,
    })

    -- Services
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Workspace = game:GetService("Workspace")
    local Camera = Workspace.CurrentCamera

    -- Store highlights and billboards for toggling
    local ActiveHighlights = {}
    local ActiveBillboards = {}
    local ActiveHealthConnections = {}
    local HighlightingEnabled = false
    local AimbotEnabled = false
    local WallCheckEnabled = true
    local TeamCheckEnabled = false
    local AimbotFOV = 200
    local AimbotSmoothness = 0.7
    local LocalPlayer = Players.LocalPlayer
    local CurrentTarget = nil
    local FOVCircle = nil
    local AimbotKey = Enum.UserInputType.MouseButton2 -- Default to right click
    local RequireHoldingTool = true -- NEW: Toggle for requiring tool holding

    -- NEW: Toggle for nearest target mode
    local NearestTargetMode = false

    -- Key binding variables
    local ListeningForKey = false
    local KeybindButton = nil

    -- Safe Zone Platform
    local SafeZonePlatform = nil
    local SafeZoneCreated = false

    -- Whitelist System
    local WhitelistedPlayers = {}
    local WhitelistEnabled = false

    -- Aimbot target tracking
    local currentAimTarget = nil  -- Store the current target while aiming
    local isAiming = false        -- Track if we're currently aiming

    -- Create Safe Zone Platform
    local function createSafeZonePlatform()
        if SafeZonePlatform and SafeZonePlatform.Parent then
            SafeZonePlatform:Destroy()
        end
        
        SafeZonePlatform = Instance.new("Part")
        SafeZonePlatform.Name = "SafeZonePlatform"
        SafeZonePlatform.Anchored = true
        SafeZonePlatform.BottomSurface = Enum.SurfaceType.Smooth
        SafeZonePlatform.BrickColor = BrickColor.new("Bright green")
        SafeZonePlatform.CFrame = CFrame.new(9999, 50, 9999)
        SafeZonePlatform.Color = Color3.new(0.294118, 0.592157, 0.294118)
        SafeZonePlatform.Material = Enum.Material.Grass
        SafeZonePlatform.Parent = workspace
        SafeZonePlatform.Position = Vector3.new(9999, 50, 9999)
        SafeZonePlatform.Size = Vector3.new(100, 1, 100)
        SafeZonePlatform.TopSurface = Enum.SurfaceType.Smooth
        
        SafeZoneCreated = true
        
        return SafeZonePlatform
    end

    -- Teleport to Safe Zone
    local function teleportToSafeZone()
        if not SafeZoneCreated or not SafeZonePlatform then
            Rayfield:Notify({
                Title = "Safe Zone Error",
                Content = "Safe Zone platform not created yet!",
                Duration = 3,
                Image = 4483362458
            })
            return
        end
        
        if not LocalPlayer.Character then
            Rayfield:Notify({
                Title = "Safe Zone Error",
                Content = "Character not found!",
                Duration = 3,
                Image = 4483362458
            })
            return
        end
        
        local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            Rayfield:Notify({
                Title = "Safe Zone Error",
                Content = "HumanoidRootPart not found!",
                Duration = 3,
                Image = 4483362458
            })
            return
        end
        
        -- Save current position before teleporting
        _G.safeZoneOriginalPosition = humanoidRootPart.Position
        
        -- Teleport to safe zone
        LocalPlayer.Character:MoveTo(SafeZonePlatform.Position + Vector3.new(0, 3, 0))
        
        Rayfield:Notify({
            Title = "Safe Zone",
            Content = "Teleported to Safe Zone!",
            Duration = 3,
            Image = 4483362458
        })
    end

    -- Teleport back from Safe Zone
    local function teleportBackFromSafeZone()
        if not _G.safeZoneOriginalPosition then
            Rayfield:Notify({
                Title = "Safe Zone Error",
                Content = "No original position saved!",
                Duration = 3,
                Image = 4483362458
            })
            return
        end
        
        if not LocalPlayer.Character then
            Rayfield:Notify({
                Title = "Safe Zone Error",
                Content = "Character not found!",
                Duration = 3,
                Image = 4483362458
            })
            return
        end
        
        local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then
            Rayfield:Notify({
                Title = "Safe Zone Error",
                Content = "HumanoidRootPart not found!",
                Duration = 3,
                Image = 4483362458
            })
            return
        end
        
        -- Teleport back to original position
        LocalPlayer.Character:MoveTo(_G.safeZoneOriginalPosition)
        
        Rayfield:Notify({
            Title = "Safe Zone",
            Content = "Teleported back to original position!",
            Duration = 3,
            Image = 4483362458
        })
    end

    -- FOV Circle Visual - Stays centered on screen
    local function createFOVCircle()
        if FOVCircle then
            FOVCircle:Remove()
        end
        
        local circle = Drawing.new("Circle")
        circle.Visible = true
        circle.Thickness = 2
        circle.Color = Color3.new(1, 1, 1)
        circle.Transparency = 1
        circle.Filled = false
        circle.Radius = AimbotFOV
        circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- Always center of screen
        circle.NumSides = 100
        
        FOVCircle = circle
        return circle
    end

    local function updateFOVCircle()
        if FOVCircle then
            FOVCircle.Radius = AimbotFOV
            FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- Always center of screen
        end
    end

    -- Function to get key name for display
    local function getKeyName(inputType)
        if inputType == Enum.UserInputType.MouseButton1 then
            return "Left Click"
        elseif inputType == Enum.UserInputType.MouseButton2 then
            return "Right Click"
        elseif inputType == Enum.UserInputType.MouseButton3 then
            return "Middle Click"
        elseif inputType.Name:match("Keyboard") then
            return inputType.Name:gsub("Keyboard", "")
        else
            return tostring(inputType.Name)
        end
    end

    -- Function to start listening for key input
    local function startKeyListen()
        ListeningForKey = true
        if KeybindButton then
            KeybindButton:Set("Press any key...")
        end
        Rayfield:Notify({
            Title = "Keybind",
            Content = "Press any key to set as aimbot key...",
            Duration = 3,
            Image = 4483362458
        })
    end

    -- Key input connection
    local keyConnection
    local function setupKeyListener()
        if keyConnection then
            keyConnection:Disconnect()
        end
        
        keyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            
            if ListeningForKey then
                ListeningForKey = false
                AimbotKey = input.UserInputType
                
                if KeybindButton then
                    KeybindButton:Set("Aimbot Key: " .. getKeyName(AimbotKey))
                end
                
                Rayfield:Notify({
                    Title = "Keybind Set",
                    Content = "Aimbot key set to: " .. getKeyName(AimbotKey),
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end)
    end

    -- Team check functions
    local function isOnSameTeam(player)
        if not TeamCheckEnabled then
            return false
        end
        
        local localPlayerTeam = LocalPlayer.Team
        local targetPlayerTeam = player.Team
        
        -- Check if both players are on the same team
        if localPlayerTeam and targetPlayerTeam then
            return localPlayerTeam == targetPlayerTeam
        end
        
        return false
    end

    -- Whitelist check function
    local function isPlayerWhitelisted(player)
        if not WhitelistEnabled then
            return false
        end
        
        return WhitelistedPlayers[player.Name] == true
    end

    -- Function to check if a model is an NPC (not a player character)
    local function isNPC(model)
        if not model or not model:IsA("Model") then
            return false
        end
        
        -- Check if it's a player character
        local player = Players:GetPlayerFromCharacter(model)
        if player then
            return false -- This is a player character
        end
        
        -- Check if it's in workspace.Models folder
        local modelsFolder = Workspace:FindFirstChild("Models")
        if modelsFolder then
            -- Check if the model is a descendant of Models folder
            local isInModels = model:IsDescendantOf(modelsFolder)
            if isInModels then
                return true -- This is an NPC in Models folder
            end
        end
        
        -- Also check if it's directly in workspace and not a player
        if model.Parent == Workspace then
            -- Additional check to make sure it's not a player character
            if not model:FindFirstChild("Humanoid") then
                return false
            end
            
            -- Check if any player has this as their character
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character == model then
                    return false
                end
            end
            
            -- Check for common NPC indicators
            if model.Name:match("NPC") or model.Name:match("Enemy") or model.Name:match("Mob") then
                return true
            end
        end
        
        return false
    end

    local function isHoldingItem()
        if not RequireHoldingTool then
            return true -- Skip tool check if the toggle is off
        end
        
        if not LocalPlayer.Character then
            return false
        end
        
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if not humanoid then
            return false
        end
        
        -- Check if holding a tool
        local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if tool then
            return true
        end
        
        -- Alternative method: check for items in hands
        local rightHand = LocalPlayer.Character:FindFirstChild("RightHand") or LocalPlayer.Character:FindFirstChild("Right Arm")
        local leftHand = LocalPlayer.Character:FindFirstChild("LeftHand") or LocalPlayer.Character:FindFirstChild("Left Arm")
        
        if rightHand then
            for _, item in pairs(rightHand:GetChildren()) do
                if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("UnionOperation") then
                    return true
                end
            end
        end
        
        if leftHand then
            for _, item in pairs(leftHand:GetChildren()) do
                if item:IsA("Part") or item:IsA("MeshPart") or item:IsA("UnionOperation") then
                    return true
                end
            end
        end
        
        return false
    end

    local function isAlive(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return humanoid.Health > 0
        end
        
        local healthSource = character:FindFirstChild("health") or character:FindFirstChild("Health")
        if healthSource and (healthSource:IsA("IntValue") or healthSource:IsA("NumberValue")) then
            return healthSource.Value > 0
        end
        
        return true -- Assume alive if no health found
    end

    local function wallCheck(targetPosition)
        if not WallCheckEnabled then
            return false
        end
        
        local origin = Camera.CFrame.Position
        local direction = (targetPosition - origin).Unit
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
        
        local raycastResult = Workspace:Raycast(origin, direction * 1000, raycastParams)
        
        if raycastResult then
            -- Check if the hit is the target or something else
            local distanceToTarget = (targetPosition - origin).Magnitude
            local distanceToHit = (raycastResult.Position - origin).Magnitude
            
            -- If something is closer than the target, there's a wall in the way
            return distanceToHit < distanceToTarget - 1
        end
        
        return false -- No walls in the way
    end

    local function findHealthValue(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            return humanoid
        end
        
        local healthObj = character:FindFirstChild("health") or character:FindFirstChild("Health")
        if healthObj then
            if healthObj:IsA("IntValue") or healthObj:IsA("NumberValue") then
                return healthObj
            end
        end
        
        local attrHealth = character:GetAttribute("Health") or character:GetAttribute("health")
        if attrHealth then
            local fakeValue = Instance.new("NumberValue")
            fakeValue.Value = attrHealth
            fakeValue.Name = "Health"
            fakeValue.Parent = character
            return fakeValue
        end
        
        return nil
    end

    local function removeESP(character)
        if ActiveHighlights[character] then
            ActiveHighlights[character]:Destroy()
            ActiveHighlights[character] = nil
        end
        
        if ActiveBillboards[character] then
            ActiveBillboards[character]:Destroy()
            ActiveBillboards[character] = nil
        end
        
        if ActiveHealthConnections[character] then
            ActiveHealthConnections[character]:Disconnect()
            ActiveHealthConnections[character] = nil
        end
    end

    local function updateAllHighlights()
        for character, highlight in pairs(ActiveHighlights) do
            if highlight and highlight.Parent then
                local player = Players:GetPlayerFromCharacter(character)
                if player and player ~= LocalPlayer then
                    if CurrentTarget and character == CurrentTarget then
                        highlight.FillColor = Color3.fromRGB(128, 0, 128) -- Purple for target
                        highlight.OutlineColor = Color3.fromRGB(200, 0, 200)
                    else
                        if isPlayerWhitelisted(player) then
                            highlight.FillColor = Color3.fromRGB(0, 100, 255) -- Blue for whitelisted
                        elseif TeamCheckEnabled and isOnSameTeam(player) then
                            highlight.FillColor = Color3.fromRGB(0, 255, 0) -- Green for teammates
                        else
                            highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red for enemies
                        end
                        highlight.OutlineColor = Color3.new(1, 1, 1)
                    end
                else
                    -- Check if it's an NPC
                    if isNPC(character) then
                        highlight.FillColor = Color3.fromRGB(255, 255, 0) -- Yellow for NPCs
                        highlight.OutlineColor = Color3.new(1, 1, 1)
                    end
                end
            end
        end
        
        -- Update billboard names as well
        for character, billboard in pairs(ActiveBillboards) do
            if billboard and billboard.Parent then
                local nameLabel = billboard:FindFirstChildOfClass("TextLabel")
                if nameLabel then
                    local player = Players:GetPlayerFromCharacter(character)
                    if player and player ~= LocalPlayer then
                        if isPlayerWhitelisted(player) then
                            nameLabel.TextColor3 = Color3.fromRGB(0, 100, 255)
                            nameLabel.Text = player.Name .. " (Whitelisted)"
                        elseif TeamCheckEnabled and isOnSameTeam(player) then
                            nameLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                            nameLabel.Text = player.Name .. " (Teammate)"
                        else
                            nameLabel.TextColor3 = Color3.new(1, 1, 1)
                            nameLabel.Text = player.Name
                        end
                    else
                        -- Check if it's an NPC
                        if isNPC(character) then
                            nameLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
                            nameLabel.Text = "NPC: " .. character.Name
                        end
                    end
                end
            end
        end
    end

    local function createHealthBar(entity, character, healthSource, isNPC)
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = character:FindFirstChild("Head") or character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        billboard.Size = UDim2.new(0, 120, 0, 40)
        billboard.StudsOffset = Vector3.new(0, 5, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = 500
        billboard.Parent = character
        
        local player = Players:GetPlayerFromCharacter(character)
        local isTeammate = player and TeamCheckEnabled and isOnSameTeam(player)
        local isWhitelisted = player and isPlayerWhitelisted(player)
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(1, 0, 0, 20)
        nameLabel.Position = UDim2.new(0, 0, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextScaled = true
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextColor3 = (isNPC and Color3.fromRGB(255, 255, 0)) or (isWhitelisted and Color3.fromRGB(0, 100, 255)) or (isTeammate and Color3.fromRGB(0, 255, 0) or Color3.new(1, 1, 1))
        nameLabel.TextStrokeTransparency = 0
        nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        
        if isNPC then
            nameLabel.Text = "NPC: " .. character.Name
        else
            if isWhitelisted then
                nameLabel.Text = entity.Name .. " (Whitelisted)"
            elseif isTeammate then
                nameLabel.Text = entity.Name .. " (Teammate)"
            else
                nameLabel.Text = entity.Name
            end
        end
        
        nameLabel.Parent = billboard
        
        local healthContainer = Instance.new("Frame")
        healthContainer.Size = UDim2.new(1, 0, 0, 15)
        healthContainer.Position = UDim2.new(0, 0, 0, 20)
        healthContainer.BackgroundColor3 = Color3.new(0, 0, 0)
        healthContainer.BorderSizePixel = 1
        healthContainer.BorderColor3 = Color3.new(1, 1, 1)
        healthContainer.Parent = billboard
        
        local healthBar = Instance.new("Frame")
        healthBar.Size = UDim2.new(1, 0, 1, 0)
        healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = healthContainer
        healthBar.ZIndex = 2
        
        local healthText = Instance.new("TextLabel")
        healthText.Size = UDim2.new(1, 0, 1, 0)
        healthText.BackgroundTransparency = 1
        healthText.TextScaled = true
        healthText.Font = Enum.Font.GothamMedium
        healthText.TextColor3 = Color3.new(1, 1, 1)
        healthText.TextStrokeTransparency = 0
        healthText.TextStrokeColor3 = Color3.new(0, 0, 0)
        healthText.Parent = healthContainer
        healthText.ZIndex = 3
        
        local function updateHealthBar()
            local currentHealth, maxHealth
            
            if healthSource:IsA("Humanoid") then
                currentHealth = healthSource.Health
                maxHealth = healthSource.MaxHealth
            elseif healthSource:IsA("IntValue") or healthSource:IsA("NumberValue") then
                currentHealth = healthSource.Value
                local maxHealthSource = character:FindFirstChild("MaxHealth") or character:FindFirstChild("maxHealth")
                maxHealth = maxHealthSource and maxHealthSource.Value or 100
            else
                currentHealth = 100
                maxHealth = 100
            end
            
            local healthPercentage = math.clamp(currentHealth / maxHealth, 0, 1)
            
            healthBar.Size = UDim2.new(healthPercentage, 0, 1, 0)
            
            if healthPercentage > 0.6 then
                healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
            elseif healthPercentage > 0.3 then
                healthBar.BackgroundColor3 = Color3.new(1, 1, 0)
            else
                healthBar.BackgroundColor3 = Color3.new(1, 0, 0)
            end
            
            healthText.Text = math.floor(currentHealth) .. "/" .. math.floor(maxHealth)
            
            -- Remove ESP if health is 0 or below
            if currentHealth <= 0 then
                removeESP(character)
            end
        end
        
        -- Store the connection for cleanup
        if healthSource:IsA("Humanoid") then
            ActiveHealthConnections[character] = healthSource:GetPropertyChangedSignal("Health"):Connect(updateHealthBar)
        elseif healthSource:IsA("IntValue") or healthSource:IsA("NumberValue") then
            ActiveHealthConnections[character] = healthSource.Changed:Connect(updateHealthBar)
        end
        
        updateHealthBar()
        
        ActiveBillboards[character] = billboard
        
        return billboard
    end

    local function highlightEntity(entity, character, isNPC)
        if not character or (not isNPC and entity == LocalPlayer) then return nil end -- Skip highlighting yourself
        
        local healthSource = findHealthValue(character)
        if not healthSource then
            return nil
        end
        
        -- Check if already dead
        local currentHealth = 0
        if healthSource:IsA("Humanoid") then
            currentHealth = healthSource.Health
        elseif healthSource:IsA("IntValue") or healthSource:IsA("NumberValue") then
            currentHealth = healthSource.Value
        end
        
        if currentHealth <= 0 then
            return nil -- Don't highlight dead entities
        end
        
        -- Determine highlight color based on type
        local fillColor, outlineColor
        if isNPC then
            fillColor = Color3.fromRGB(255, 255, 0) -- Yellow for NPCs
            outlineColor = Color3.new(1, 1, 1)
        else
            local player = entity
            
            -- Check if player is whitelisted
            if isPlayerWhitelisted(player) then
                fillColor = Color3.fromRGB(0, 100, 255) -- Blue for whitelisted players
                outlineColor = Color3.new(1, 1, 1)
            elseif TeamCheckEnabled and isOnSameTeam(player) then
                fillColor = Color3.fromRGB(0, 255, 0) -- Green for teammates
                outlineColor = Color3.new(1, 1, 1)
            else
                fillColor = Color3.fromRGB(255, 0, 0) -- Red for enemies
                outlineColor = Color3.new(1, 1, 1)
            end
        end
        
        -- Create highlight
        local highlight = Instance.new("Highlight")
        highlight.Adornee = character
        highlight.FillColor = fillColor
        highlight.OutlineColor = outlineColor
        highlight.FillTransparency = 0.3
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Parent = character
        
        -- Create health bar with name
        createHealthBar(entity, character, healthSource, isNPC)
        
        ActiveHighlights[character] = highlight
        
        return highlight
    end

    local function removeAllHighlights()
        for character, highlight in pairs(ActiveHighlights) do
            if highlight then
                highlight:Destroy()
            end
        end
        
        for character, billboard in pairs(ActiveBillboards) do
            if billboard then
                billboard:Destroy()
            end
        end
        
        for character, connection in pairs(ActiveHealthConnections) do
            if connection then
                connection:Disconnect()
            end
        end
        
        ActiveHighlights = {}
        ActiveBillboards = {}
        ActiveHealthConnections = {}
        CurrentTarget = nil
    end

    local function processExistingPlayers()
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character and player ~= LocalPlayer then
                highlightEntity(player, player.Character, false)
            end
        end
    end

    local function processExistingNPCs()
        -- Check workspace.Models folder for NPCs
        local modelsFolder = Workspace:FindFirstChild("Models")
        if modelsFolder then
            for _, model in pairs(modelsFolder:GetChildren()) do
                if model:IsA("Model") and isAlive(model) then
                    -- Make sure it's not a player character
                    local player = Players:GetPlayerFromCharacter(model)
                    if not player then
                        highlightEntity(model, model, true)
                    end
                end
            end
        end
        
        -- Also check for NPCs directly in workspace (backup)
        for _, model in pairs(Workspace:GetChildren()) do
            if model:IsA("Model") and isAlive(model) then
                -- Make sure it's not a player character
                local player = Players:GetPlayerFromCharacter(model)
                if not player and model ~= LocalPlayer.Character then
                    -- Additional NPC checks
                    if model:FindFirstChild("Humanoid") and not model:FindFirstChild("PlayerScripts") then
                        if model.Name:match("NPC") or model.Name:match("Enemy") or model.Name:match("Mob") then
                            highlightEntity(model, model, true)
                        end
                    end
                end
            end
        end
    end

    -- FIXED: Check if mouse is inside FOV circle (same for both modes)
    local function isMouseInFOV()
        local mouseLocation = UserInputService:GetMouseLocation()
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local distanceFromCenter = (mouseLocation - screenCenter).Magnitude
        return distanceFromCenter <= AimbotFOV
    end

    -- FIXED: FOV check uses CENTER of screen for target distance (only used when NOT in nearest target mode)
    local function isTargetInFOV(targetPart)
        if NearestTargetMode then
            return true -- In nearest target mode, consider all targets
        end
        
        if not targetPart then
            return false
        end
        
        local targetPosition, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
        
        if not onScreen then
            return false
        end
        
        -- Calculate distance from CENTER of screen to target on screen
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
        
        -- Check if target is within FOV circle (using screen center as center)
        return distance <= AimbotFOV
    end

    -- NEW: Get all valid targets for NEAREST TARGET MODE (based on physical distance, not screen position)
    local function getAllValidTargetsNearest()
        local validTargets = {}
        local localCharacter = LocalPlayer.Character
        local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
        
        if not localRoot then
            return validTargets
        end
        
        local localPosition = localRoot.Position
        
        -- Check players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and isAlive(player.Character) then
                -- Skip teammates if team check is enabled
                if TeamCheckEnabled and isOnSameTeam(player) then
                    continue
                end
                
                -- Skip whitelisted players
                if isPlayerWhitelisted(player) then
                    continue
                end
                
                -- Try to find head first, then torso, then humanoid root part
                local head = player.Character:FindFirstChild("Head")
                local torso = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso")
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                
                local targetPart = head or torso or humanoidRootPart
                if targetPart then
                    local distance = (targetPart.Position - localPosition).Magnitude
                    
                    if not wallCheck(targetPart.Position) then
                        table.insert(validTargets, {
                            targetPart = targetPart,
                            character = player.Character,
                            distance = distance,
                            type = "player"
                        })
                    end
                end
            end
        end
        
        -- Check NPCs in workspace.Models folder
        local modelsFolder = Workspace:FindFirstChild("Models")
        if modelsFolder then
            for _, npc in pairs(modelsFolder:GetChildren()) do
                if npc:IsA("Model") and isAlive(npc) then
                    -- Make sure it's not a player character
                    local player = Players:GetPlayerFromCharacter(npc)
                    if not player then
                        local head = npc:FindFirstChild("Head")
                        local torso = npc:FindFirstChild("Torso") or npc:FindFirstChild("UpperTorso")
                        local humanoidRootPart = npc:FindFirstChild("HumanoidRootPart")
                        
                        local targetPart = head or torso or humanoidRootPart
                        if targetPart then
                            local distance = (targetPart.Position - localPosition).Magnitude
                            
                            if not wallCheck(targetPart.Position) then
                                table.insert(validTargets, {
                                    targetPart = targetPart,
                                    character = npc,
                                    distance = distance,
                                    type = "npc"
                                })
                            end
                        end
                    end
                end
            end
        end
        
        -- Also check for NPCs directly in workspace (backup)
        for _, npc in pairs(Workspace:GetChildren()) do
            if npc:IsA("Model") and isAlive(npc) then
                -- Make sure it's not a player character
                local player = Players:GetPlayerFromCharacter(npc)
                if not player and npc ~= LocalPlayer.Character then
                    -- Additional NPC checks
                    if npc:FindFirstChild("Humanoid") and not npc:FindFirstChild("PlayerScripts") then
                        if npc.Name:match("NPC") or npc.Name:match("Enemy") or npc.Name:match("Mob") then
                            local head = npc:FindFirstChild("Head")
                            local torso = npc:FindFirstChild("Torso") or npc:FindFirstChild("UpperTorso")
                            local humanoidRootPart = npc:FindFirstChild("HumanoidRootPart")
                            
                            local targetPart = head or torso or humanoidRootPart
                            if targetPart then
                                local distance = (targetPart.Position - localPosition).Magnitude
                                
                                if not wallCheck(targetPart.Position) then
                                    table.insert(validTargets, {
                                        targetPart = targetPart,
                                        character = npc,
                                        distance = distance,
                                        type = "npc"
                                    })
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return validTargets
    end

    -- FIXED: Unified target collection that checks ALL entities together using CENTER FOV (only used when NOT in nearest target mode)
    local function getAllValidTargetsFOV()
        local validTargets = {}
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        -- Check players
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and isAlive(player.Character) then
                -- Skip teammates if team check is enabled
                if TeamCheckEnabled and isOnSameTeam(player) then
                    continue
                end
                
                -- Skip whitelisted players
                if isPlayerWhitelisted(player) then
                    continue
                end
                
                -- Try to find head first, then torso, then humanoid root part
                local head = player.Character:FindFirstChild("Head")
                local torso = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso")
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                
                local targetPart = head or torso or humanoidRootPart
                if targetPart and isTargetInFOV(targetPart) then
                    local targetPosition = Camera:WorldToViewportPoint(targetPart.Position)
                    local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
                    
                    if not wallCheck(targetPart.Position) then
                        table.insert(validTargets, {
                            targetPart = targetPart,
                            character = player.Character,
                            distance = distance,
                            type = "player"
                        })
                    end
                end
            end
        end
        
        -- Check NPCs in workspace.Models folder
        local modelsFolder = Workspace:FindFirstChild("Models")
        if modelsFolder then
            for _, npc in pairs(modelsFolder:GetChildren()) do
                if npc:IsA("Model") and isAlive(npc) then
                    -- Make sure it's not a player character
                    local player = Players:GetPlayerFromCharacter(npc)
                    if not player then
                        local head = npc:FindFirstChild("Head")
                        local torso = npc:FindFirstChild("Torso") or npc:FindFirstChild("UpperTorso")
                        local humanoidRootPart = npc:FindFirstChild("HumanoidRootPart")
                        
                        local targetPart = head or torso or humanoidRootPart
                        if targetPart and isTargetInFOV(targetPart) then
                            local targetPosition = Camera:WorldToViewportPoint(targetPart.Position)
                            local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
                            
                            if not wallCheck(targetPart.Position) then
                                table.insert(validTargets, {
                                    targetPart = targetPart,
                                    character = npc,
                                    distance = distance,
                                    type = "npc"
                                })
                            end
                        end
                    end
                end
            end
        end
        
        -- Also check for NPCs directly in workspace (backup)
        for _, npc in pairs(Workspace:GetChildren()) do
            if npc:IsA("Model") and isAlive(npc) then
                -- Make sure it's not a player character
                local player = Players:GetPlayerFromCharacter(npc)
                if not player and npc ~= LocalPlayer.Character then
                    -- Additional NPC checks
                    if npc:FindFirstChild("Humanoid") and not npc:FindFirstChild("PlayerScripts") then
                        if npc.Name:match("NPC") or npc.Name:match("Enemy") or npc.Name:match("Mob") then
                            local head = npc:FindFirstChild("Head")
                            local torso = npc:FindFirstChild("Torso") or npc:FindFirstChild("UpperTorso")
                            local humanoidRootPart = npc:FindFirstChild("HumanoidRootPart")
                            
                            local targetPart = head or torso or humanoidRootPart
                            if targetPart and isTargetInFOV(targetPart) then
                                local targetPosition = Camera:WorldToViewportPoint(targetPart.Position)
                                local distance = (Vector2.new(targetPosition.X, targetPosition.Y) - screenCenter).Magnitude
                                
                                if not wallCheck(targetPart.Position) then
                                    table.insert(validTargets, {
                                        targetPart = targetPart,
                                        character = npc,
                                        distance = distance,
                                        type = "npc"
                                    })
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return validTargets
    end

    -- FIXED: Aimbot target selection - chooses based on current mode
    local function getClosestTargetToCursor()
        local validTargets
        local closestTarget = nil
        local closestCharacter = nil
        local closestDistance = math.huge
        
        if NearestTargetMode then
            -- Get targets based on physical distance
            validTargets = getAllValidTargetsNearest()
            
            -- Find the closest target (physically closest)
            for _, targetData in pairs(validTargets) do
                if targetData.distance < closestDistance then
                    closestDistance = targetData.distance
                    closestTarget = targetData.targetPart
                    closestCharacter = targetData.character
                end
            end
        else
            -- Get targets based on FOV
            validTargets = getAllValidTargetsFOV()
            
            -- Find the closest target to center of screen
            for _, targetData in pairs(validTargets) do
                if targetData.distance < closestDistance then
                    closestDistance = targetData.distance
                    closestTarget = targetData.targetPart
                    closestCharacter = targetData.character
                end
            end
        end
        
        return closestTarget, closestDistance, closestCharacter
    end

    local function aimAtTarget(targetPart)
        if not targetPart then return end
        
        -- Calculate the direction to the target part
        local camera = Workspace.CurrentCamera
        local targetPosition = targetPart.Position
        
        -- Create a CFrame that looks at the target
        local lookAt = CFrame.lookAt(camera.CFrame.Position, targetPosition)
        
        -- Smoothly interpolate the camera
        camera.CFrame = camera.CFrame:Lerp(lookAt, AimbotSmoothness)
    end

    -- Fixed Aimbot loop - BOTH MODES require mouse inside FOV circle
    local aimbotConnection
    local function startAimbot()
        if aimbotConnection then
            aimbotConnection:Disconnect()
        end
        
        aimbotConnection = RunService.RenderStepped:Connect(function()
            if AimbotEnabled and UserInputService:GetFocusedTextBox() == nil then
                local isAimbotKeyPressed = false
                
                -- Check if the current aimbot key is pressed
                if AimbotKey == Enum.UserInputType.MouseButton1 or AimbotKey == Enum.UserInputType.MouseButton2 or AimbotKey == Enum.UserInputType.MouseButton3 then
                    isAimbotKeyPressed = UserInputService:IsMouseButtonPressed(AimbotKey)
                else
                    -- For keyboard keys, we need to check differently
                    isAimbotKeyPressed = UserInputService:IsKeyDown(Enum.KeyCode[AimbotKey.Name])
                end
                
                -- Check conditions for aiming - BOTH MODES require mouse inside FOV
                local shouldAim = false
                if isAimbotKeyPressed then
                    -- Check tool requirement
                    if RequireHoldingTool and not isHoldingItem() then
                        shouldAim = false
                    else
                        -- BOTH MODES require mouse to be inside FOV circle
                        shouldAim = isMouseInFOV()
                    end
                end
                
                if shouldAim then
                    if not isAiming then
                        -- Just started aiming - find initial target
                        local closestTarget, distance, closestCharacter = getClosestTargetToCursor()
                        if closestTarget then
                            currentAimTarget = closestTarget
                            CurrentTarget = closestCharacter
                            updateAllHighlights()
                            isAiming = true
                        end
                    end
                    
                    -- Continue aiming at the current target
                    if currentAimTarget and currentAimTarget.Parent and isAlive(currentAimTarget.Parent) then
                        aimAtTarget(currentAimTarget)
                    else
                        -- Current target is no longer valid, find new one
                        local closestTarget, distance, closestCharacter = getClosestTargetToCursor()
                        if closestTarget then
                            currentAimTarget = closestTarget
                            CurrentTarget = closestCharacter
                            updateAllHighlights()
                        else
                            currentAimTarget = nil
                            CurrentTarget = nil
                            updateAllHighlights()
                        end
                    end
                else
                    -- Not aiming conditions met
                    if isAiming then
                        -- Just stopped aiming
                        currentAimTarget = nil
                        CurrentTarget = nil
                        updateAllHighlights()
                        isAiming = false
                    end
                end
            else
                -- Aimbot disabled or text box focused
                currentAimTarget = nil
                CurrentTarget = nil
                updateAllHighlights()
                isAiming = false
            end
        end)
    end

    local function stopAimbot()
        if aimbotConnection then
            aimbotConnection:Disconnect()
            aimbotConnection = nil
        end
        currentAimTarget = nil
        CurrentTarget = nil
        isAiming = false
        updateAllHighlights()
    end

    -- Create Tabs
    local ESPTab = Window:CreateTab("ESP", "user")
    local AimbotTab = Window:CreateTab("Aimbot", "target")
    local SafeZoneTab = Window:CreateTab("Safe Zone", "shield-check")
    local WhitelistTab = Window:CreateTab("Whitelist", "shield")

    -- ESP Tab
    ESPTab:CreateSection("Player & NPC Highlighter")

    -- Main Toggle
    local HighlightToggle = ESPTab:CreateToggle({
        Name = "Enable Player & NPC Highlighting",
        CurrentValue = false,
        Flag = "HighlightToggle",
        Callback = function(Value)
            HighlightingEnabled = Value
            if Value then
                processExistingPlayers()
                processExistingNPCs()
                
                -- Connect to player added event
                Players.PlayerAdded:Connect(function(player)
                    player.CharacterAdded:Connect(function(character)
                        wait(1)
                        if player ~= LocalPlayer then
                            highlightEntity(player, character, false)
                        end
                    end)
                end)
                
                -- Connect to character added events for existing players
                for _, player in pairs(Players:GetPlayers()) do
                    player.CharacterAdded:Connect(function(character)
                        wait(1)
                        if player ~= LocalPlayer then
                            highlightEntity(player, character, false)
                        end
                    end)
                end
                
                -- Connect to Models folder changes for NPCs
                local modelsFolder = Workspace:FindFirstChild("Models")
                if modelsFolder then
                    modelsFolder.ChildAdded:Connect(function(model)
                        wait(1)
                        if model:IsA("Model") and isNPC(model) then
                            highlightEntity(model, model, true)
                        end
                    end)
                end
                
                Rayfield:Notify({
                    Title = "Player & NPC Highlighting",
                    Content = "Highlighting has been enabled (Yourself is not highlighted)",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                removeAllHighlights()
                Rayfield:Notify({
                    Title = "Player & NPC Highlighting",
                    Content = "Highlighting has been disabled",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Team Check Toggle
    local TeamCheckToggle = ESPTab:CreateToggle({
        Name = "Team Check (Green = Teammates)",
        CurrentValue = false,
        Flag = "TeamCheckToggle",
        Callback = function(Value)
            TeamCheckEnabled = Value
            if HighlightingEnabled then
                updateAllHighlights() -- Update existing highlights instead of recreating them
            end
            local message = Value and "Team check enabled - Teammates will be green" or "Team check disabled - All players are enemies"
            Rayfield:Notify({
                Title = "Team Settings",
                Content = message,
                Duration = 3,
                Image = 4483362458
            })
        end,
    })

    -- Refresh Button
    ESPTab:CreateButton({
        Name = "Refresh Players & NPCs",
        Callback = function()
            if HighlightingEnabled then
                removeAllHighlights()
                processExistingPlayers()
                processExistingNPCs()
                Rayfield:Notify({
                    Title = "Player & NPC Highlighter",
                    Content = "Highlights refreshed",
                    Duration = 2,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Player & NPC Highlighter",
                    Content = "Enable highlighting first!",
                    Duration = 2,
                    Image = 4483362458
                })
            end
        end,
    })

    -- ESP Settings Section
    ESPTab:CreateSection("ESP Settings")

    -- Highlight Color Picker
    local HighlightColor = ESPTab:CreateColorPicker({
        Name = "Enemy Highlight Color",
        Color = Color3.fromRGB(255, 0, 0),
        Flag = "HighlightColor",
        Callback = function(Value)
            for character, highlight in pairs(ActiveHighlights) do
                if highlight and highlight.Parent then
                    local player = Players:GetPlayerFromCharacter(character)
                    if player and player ~= LocalPlayer and character ~= CurrentTarget and not (TeamCheckEnabled and isOnSameTeam(player)) and not isPlayerWhitelisted(player) then
                        highlight.FillColor = Value
                    end
                end
            end
        end
    })

    -- Target Highlight Color Picker
    local TargetHighlightColor = ESPTab:CreateColorPicker({
        Name = "Target Highlight Color",
        Color = Color3.fromRGB(128, 0, 128),
        Flag = "TargetHighlightColor",
        Callback = function(Value)
            if CurrentTarget and ActiveHighlights[CurrentTarget] then
                ActiveHighlights[CurrentTarget].FillColor = Value
                ActiveHighlights[CurrentTarget].OutlineColor = Color3.fromRGB(200, 0, 200)
            end
        end
    })

    -- Teammate Highlight Color Picker
    local TeammateHighlightColor = ESPTab:CreateColorPicker({
        Name = "Teammate Highlight Color",
        Color = Color3.fromRGB(0, 255, 0),
        Flag = "TeammateHighlightColor",
        Callback = function(Value)
            for character, highlight in pairs(ActiveHighlights) do
                if highlight and highlight.Parent then
                    local player = Players:GetPlayerFromCharacter(character)
                    if player and TeamCheckEnabled and isOnSameTeam(player) then
                        highlight.FillColor = Value
                    end
                end
            end
        end
    })

    -- Whitelist Highlight Color Picker
    local WhitelistHighlightColor = ESPTab:CreateColorPicker({
        Name = "Whitelist Highlight Color",
        Color = Color3.fromRGB(0, 100, 255),
        Flag = "WhitelistHighlightColor",
        Callback = function(Value)
            for character, highlight in pairs(ActiveHighlights) do
                if highlight and highlight.Parent then
                    local player = Players:GetPlayerFromCharacter(character)
                    if player and isPlayerWhitelisted(player) then
                        highlight.FillColor = Value
                    end
                end
            end
        end
    })

    -- NPC Highlight Color Picker
    local NPCHighlightColor = ESPTab:CreateColorPicker({
        Name = "NPC Highlight Color",
        Color = Color3.fromRGB(255, 255, 0),
        Flag = "NPCHighlightColor",
        Callback = function(Value)
            for character, highlight in pairs(ActiveHighlights) do
                if highlight and highlight.Parent then
                    if isNPC(character) then
                        highlight.FillColor = Value
                    end
                end
            end
        end
    })

    -- Highlight Transparency Slider
    local TransparencySlider = ESPTab:CreateSlider({
        Name = "Highlight Transparency",
        Range = {0, 100},
        Increment = 5,
        Suffix = "%",
        CurrentValue = 30,
        Flag = "HighlightTransparency",
        Callback = function(Value)
            local transparency = Value / 100
            for character, highlight in pairs(ActiveHighlights) do
                if highlight and highlight.Parent then
                    highlight.FillTransparency = transparency
                end
            end
        end,
    })

    -- Aimbot Tab
    AimbotTab:CreateSection("Aimbot")

    -- Aimbot Toggle
    local AimbotToggle = AimbotTab:CreateToggle({
        Name = "Enable Aimbot",
        CurrentValue = false,
        Flag = "AimbotToggle",
        Callback = function(Value)
            AimbotEnabled = Value
            if Value then
                startAimbot()
                createFOVCircle()
                FOVCircle.Visible = true -- Always show FOV circle
                
                -- Build notification message based on settings
                local message = "Aimbot enabled - Hold " .. getKeyName(AimbotKey)
                if RequireHoldingTool then
                    message = message .. " while holding an item AND mouse inside FOV circle to aim"
                else
                    message = message .. " while mouse inside FOV circle to aim"
                end
                
                if NearestTargetMode then
                    message = message .. " (Nearest Target Mode)"
                else
                    message = message .. " (FOV Mode)"
                end
                
                Rayfield:Notify({
                    Title = "Aimbot",
                    Content = message,
                    Duration = 4,
                    Image = 4483362458
                })
            else
                stopAimbot()
                if FOVCircle then
                    FOVCircle.Visible = false
                end
                Rayfield:Notify({
                    Title = "Aimbot",
                    Content = "Aimbot disabled",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- NEW: Nearest Target Mode Toggle
    local NearestTargetToggle = AimbotTab:CreateToggle({
        Name = "Nearest Target Mode",
        CurrentValue = false,
        Flag = "NearestTargetToggle",
        Callback = function(Value)
            NearestTargetMode = Value
            
            if Value then
                Rayfield:Notify({
                    Title = "Aimbot Mode",
                    Content = "Switched to Nearest Target Mode - Targets closest entity to you (still requires mouse inside FOV)",
                    Duration = 4,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Aimbot Mode",
                    Content = "Switched to FOV Mode - Targets closest to cursor within FOV circle",
                    Duration = 4,
                    Image = 4483362458
                })
            end
            
            -- Update notification text
            if AimbotEnabled then
                -- Build notification message based on settings
                local message = "Aimbot updated - Hold " .. getKeyName(AimbotKey)
                if RequireHoldingTool then
                    message = message .. " while holding an item AND mouse inside FOV circle to aim"
                else
                    message = message .. " while mouse inside FOV circle to aim"
                end
                
                if NearestTargetMode then
                    message = message .. " (Nearest Target Mode)"
                else
                    message = message .. " (FOV Mode)"
                end
                
                Rayfield:Notify({
                    Title = "Aimbot",
                    Content = message,
                    Duration = 4,
                    Image = 4483362458
                })
            end
        end,
    })

    -- NEW: Tool Requirement Toggle
    local ToolRequirementToggle = AimbotTab:CreateToggle({
        Name = "Require Holding Tool",
        CurrentValue = true,
        Flag = "ToolRequirementToggle",
        Callback = function(Value)
            RequireHoldingTool = Value
            local message = Value and "Aimbot now requires holding a tool" or "Aimbot works without holding a tool"
            Rayfield:Notify({
                Title = "Aimbot Settings",
                Content = message,
                Duration = 3,
                Image = 4483362458
            })
            
            -- Update notification text
            if AimbotEnabled then
                -- Build notification message based on settings
                local message = "Aimbot updated - Hold " .. getKeyName(AimbotKey)
                if RequireHoldingTool then
                    message = message .. " while holding an item AND mouse inside FOV circle to aim"
                else
                    message = message .. " while mouse inside FOV circle to aim"
                end
                
                if NearestTargetMode then
                    message = message .. " (Nearest Target Mode)"
                else
                    message = message .. " (FOV Mode)"
                end
                
                Rayfield:Notify({
                    Title = "Aimbot",
                    Content = message,
                    Duration = 4,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Aimbot Keybind Button
    KeybindButton = AimbotTab:CreateButton({
        Name = "Aimbot Key: " .. getKeyName(AimbotKey),
        Callback = function()
            startKeyListen()
        end,
    })

    -- Aimbot Settings
    local AimbotFOVSlider = AimbotTab:CreateSlider({
        Name = "Aimbot FOV (Pixels)",
        Range = {50, 500},
        Increment = 10,
        Suffix = "px",
        CurrentValue = 200,
        Flag = "AimbotFOV",
        Callback = function(Value)
            AimbotFOV = Value
            updateFOVCircle()
            Rayfield:Notify({
                Title = "Aimbot Settings",
                Content = "Aimbot FOV set to " .. Value .. " pixels",
                Duration = 2,
                Image = 4483362458
            })
        end,
    })

    local AimbotSmoothnessSlider = AimbotTab:CreateSlider({
        Name = "Aimbot Smoothness",
        Range = {10, 90},
        Increment = 5,
        Suffix = "%",
        CurrentValue = 70,
        Flag = "AimbotSmoothness",
        Callback = function(Value)
            AimbotSmoothness = Value / 100
            Rayfield:Notify({
                Title = "Aimbot Settings",
                Content = "Aimbot smoothness set to " .. Value .. "%",
                Duration = 2,
                Image = 4483362458
            })
        end,
    })

    -- Wall Check Toggle
    local WallCheckToggle = AimbotTab:CreateToggle({
        Name = "Wall Check (Recommended)",
        CurrentValue = true,
        Flag = "WallCheckToggle",
        Callback = function(Value)
            WallCheckEnabled = Value
            local message = Value and "Wall check enabled" or "Wall check disabled"
            Rayfield:Notify({
                Title = "Aimbot Settings",
                Content = message,
                Duration = 2,
                Image = 4483362458
            })
        end,
    })

    -- FOV Circle Toggle
    local FOVCircleToggle = AimbotTab:CreateToggle({
        Name = "Show FOV Circle",
        CurrentValue = true,
        Flag = "FOVCircleToggle",
        Callback = function(Value)
            if FOVCircle then
                FOVCircle.Visible = Value
            end
            local message = Value and "FOV circle shown" or "FOV circle hidden"
            Rayfield:Notify({
                Title = "Aimbot Settings",
                Content = message,
                Duration = 2,
                Image = 4483362458
            })
        end,
    })

    -- Safe Zone Tab
    SafeZoneTab:CreateSection("Safe Zone Platform")

    -- Create Safe Zone Platform Button
    SafeZoneTab:CreateButton({
        Name = "Create Safe Zone Platform",
        Callback = function()
            createSafeZonePlatform()
            Rayfield:Notify({
                Title = "Safe Zone",
                Content = "Safe Zone platform created at position (9999, 50, 9999)",
                Duration = 4,
                Image = 4483362458
            })
        end,
    })

    -- Teleport to Safe Zone Button
    SafeZoneTab:CreateButton({
        Name = "Teleport to Safe Zone",
        Callback = function()
            teleportToSafeZone()
        end,
    })

    -- Teleport Back Button
    SafeZoneTab:CreateButton({
        Name = "Teleport Back from Safe Zone",
        Callback = function()
            teleportBackFromSafeZone()
        end,
    })

    -- Info Section
    SafeZoneTab:CreateSection("Safe Zone Info")

    SafeZoneTab:CreateParagraph({
        Title = "Safe Zone Info",
        Content = "Create a safe zone platform at position (9999, 50, 9999) where you can teleport to avoid danger. Your original position is saved so you can teleport back. The platform is green and made of grass material."
    })

    -- Whitelist Tab
    WhitelistTab:CreateSection("Whitelist Settings")

    -- Whitelist Toggle
    local WhitelistToggle = WhitelistTab:CreateToggle({
        Name = "Enable Player Whitelist",
        CurrentValue = false,
        Flag = "WhitelistToggle",
        Callback = function(Value)
            WhitelistEnabled = Value
            if HighlightingEnabled then
                updateAllHighlights()
            end
            local message = Value and "Whitelist enabled - Whitelisted players will be blue and ignored by aimbot" or "Whitelist disabled"
            Rayfield:Notify({
                Title = "Whitelist Settings",
                Content = message,
                Duration = 3,
                Image = 4483362458
            })
        end,
    })

    -- Player List Section
    WhitelistTab:CreateSection("Player List")

    -- Get all current players
    local function getPlayerNames()
        local playerNames = {}
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                table.insert(playerNames, player.Name)
            end
        end
        table.sort(playerNames)
        return playerNames
    end

    -- Create player dropdown
    local PlayerDropdown = WhitelistTab:CreateDropdown({
        Name = "Select Player",
        Options = getPlayerNames(),
        CurrentOption = {},
        MultipleOptions = false,
        Flag = "PlayerDropdown",
        Callback = function(Option)
            -- This will be used when adding players
        end,
    })

    -- Refresh player list button
    WhitelistTab:CreateButton({
        Name = "Refresh Player List",
        Callback = function()
            PlayerDropdown:Refresh(getPlayerNames())
            Rayfield:Notify({
                Title = "Whitelist",
                Content = "Player list refreshed",
                Duration = 2,
                Image = 4483362458
            })
        end,
    })

    -- Whitelist Management Section
    WhitelistTab:CreateSection("Whitelist Management")

    -- Add player to whitelist
    WhitelistTab:CreateButton({
        Name = "Add Selected Player to Whitelist",
        Callback = function()
            local selectedPlayer = PlayerDropdown.CurrentOption[1]
            if selectedPlayer then
                WhitelistedPlayers[selectedPlayer] = true
                if HighlightingEnabled then
                    updateAllHighlights()
                end
                Rayfield:Notify({
                    Title = "Whitelist",
                    Content = "Added " .. selectedPlayer .. " to whitelist",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Whitelist Error",
                    Content = "Please select a player first",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Remove player from whitelist
    WhitelistTab:CreateButton({
        Name = "Remove Selected Player from Whitelist",
        Callback = function()
            local selectedPlayer = PlayerDropdown.CurrentOption[1]
            if selectedPlayer and WhitelistedPlayers[selectedPlayer] then
                WhitelistedPlayers[selectedPlayer] = nil
                if HighlightingEnabled then
                    updateAllHighlights()
                end
                Rayfield:Notify({
                    Title = "Whitelist",
                    Content = "Removed " .. selectedPlayer .. " from whitelist",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Whitelist Error",
                    Content = "Player not in whitelist or no player selected",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Clear all whitelist
    WhitelistTab:CreateButton({
        Name = "Clear All Whitelisted Players",
        Callback = function()
            WhitelistedPlayers = {}
            if HighlightingEnabled then
                updateAllHighlights()
            end
            Rayfield:Notify({
                Title = "Whitelist",
                Content = "Cleared all whitelisted players",
                Duration = 3,
                Image = 4483362458
            })
        end,
    })

    -- Show current whitelist
    WhitelistTab:CreateButton({
        Name = "Show Whitelisted Players",
        Callback = function()
            local whitelistedNames = {}
            for name, _ in pairs(WhitelistedPlayers) do
                table.insert(whitelistedNames, name)
            end
            
            if #whitelistedNames > 0 then
                table.sort(whitelistedNames)
                Rayfield:Notify({
                    Title = "Whitelisted Players (" .. #whitelistedNames .. ")",
                    Content = table.concat(whitelistedNames, ", "),
                    Duration = 6,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Whitelisted Players",
                    Content = "No players are whitelisted",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Auto-refresh player list when players join/leave
    Players.PlayerAdded:Connect(function(player)
        task.wait(1) -- Wait a bit for player to fully load
        PlayerDropdown:Refresh(getPlayerNames())
    end)

    Players.PlayerRemoving:Connect(function(player)
        PlayerDropdown:Refresh(getPlayerNames())
    end)

    -- Removals Tab
    local RemovalsTab = Window:CreateTab("Removals", "trash")

    -- Variables for automatic removal
    local AutoRemoveEyepatchUI = false
    local AutoRemoveWakeUpBlur = false

    -- Function to delete EyepatchUI
    local function deleteEyepatchUI()
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        
        if player then
            local playerGui = player:WaitForChild("PlayerGui")
            local ui = playerGui:FindFirstChild("EyepatchUI")
            if ui then
                ui:Destroy()
                return true
            end
        end
        return false
    end

    -- Function to delete WakeUpBlur
    local function deleteWakeUpBlur()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local clientEffects = ReplicatedStorage:FindFirstChild("ClientEffects")
        if clientEffects then
            local wakeUpBlur = clientEffects:FindFirstChild("WakeUpBlur")
            if wakeUpBlur then
                wakeUpBlur:Destroy()
                return true
            end
        end
        return false
    end

    -- Auto-removal loop
    local removalConnection
    local function startAutoRemoval()
        if removalConnection then
            removalConnection:Disconnect()
        end
        
        removalConnection = RunService.Heartbeat:Connect(function()
            if AutoRemoveEyepatchUI then
                deleteEyepatchUI()
            end
            
            if AutoRemoveWakeUpBlur then
                deleteWakeUpBlur()
            end
        end)
    end

    local function stopAutoRemoval()
        if removalConnection then
            removalConnection:Disconnect()
            removalConnection = nil
        end
    end

    -- Removals Tab Content
    RemovalsTab:CreateSection("Automatic UI Removal")

    -- EyepatchUI Toggle
    local EyepatchUIToggle = RemovalsTab:CreateToggle({
        Name = "Auto Remove EyepatchUI",
        CurrentValue = false,
        Flag = "EyepatchUIToggle",
        Callback = function(Value)
            AutoRemoveEyepatchUI = Value
            if Value then
                -- Try to delete immediately
                if deleteEyepatchUI() then
                    Rayfield:Notify({
                        Title = "Removals",
                        Content = "EyepatchUI deleted and auto-removal enabled",
                        Duration = 3,
                        Image = 4483362458
                    })
                else
                    Rayfield:Notify({
                        Title = "Removals",
                        Content = "EyepatchUI auto-removal enabled (not currently found)",
                        Duration = 3,
                        Image = 4483362458
                    })
                end
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "EyepatchUI auto-removal disabled",
                    Duration = 3,
                    Image = 4483362458
                })
            end
            
            -- Update auto-removal system
            if AutoRemoveEyepatchUI or AutoRemoveWakeUpBlur then
                startAutoRemoval()
            else
                stopAutoRemoval()
            end
        end,
    })

    -- WakeUpBlur Toggle
    local WakeUpBlurToggle = RemovalsTab:CreateToggle({
        Name = "Auto Remove WakeUpBlur",
        CurrentValue = false,
        Flag = "WakeUpBlurToggle",
        Callback = function(Value)
            AutoRemoveWakeUpBlur = Value
            if Value then
                -- Try to delete immediately
                if deleteWakeUpBlur() then
                    Rayfield:Notify({
                        Title = "Removals",
                        Content = "WakeUpBlur deleted and auto-removal enabled",
                        Duration = 3,
                        Image = 4483362458
                    })
                else
                    Rayfield:Notify({
                        Title = "Removals",
                        Content = "WakeUpBlur auto-removal enabled (not currently found)",
                        Duration = 3,
                        Image = 4483362458
                    })
                end
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "WakeUpBlur auto-removal disabled",
                    Duration = 3,
                    Image = 4483362458
                })
            end
            
            -- Update auto-removal system
            if AutoRemoveEyepatchUI or AutoRemoveWakeUpBlur then
                startAutoRemoval()
            else
                stopAutoRemoval()
            end
        end,
    })

    -- Manual Removal Section
    RemovalsTab:CreateSection("Manual Removal")

    -- Manual EyepatchUI Removal Button
    RemovalsTab:CreateButton({
        Name = "Delete EyepatchUI Now",
        Callback = function()
            if deleteEyepatchUI() then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "EyepatchUI deleted successfully!",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "EyepatchUI not found",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Manual WakeUpBlur Removal Button
    RemovalsTab:CreateButton({
        Name = "Delete WakeUpBlur Now",
        Callback = function()
            if deleteWakeUpBlur() then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "WakeUpBlur deleted successfully!",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "WakeUpBlur not found",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Delete Both Button
    RemovalsTab:CreateButton({
        Name = "Delete Both Now",
        Callback = function()
            local deletedEyepatch = deleteEyepatchUI()
            local deletedWakeUp = deleteWakeUpBlur()
            
            if deletedEyepatch and deletedWakeUp then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "Both EyepatchUI and WakeUpBlur deleted!",
                    Duration = 3,
                    Image = 4483362458
                })
            elseif deletedEyepatch then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "EyepatchUI deleted (WakeUpBlur not found)",
                    Duration = 3,
                    Image = 4483362458
                })
            elseif deletedWakeUp then
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "WakeUpBlur deleted (EyepatchUI not found)",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Removals",
                    Content = "Neither EyepatchUI nor WakeUpBlur found",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end,
    })

    -- Info Section
    RemovalsTab:CreateSection("Removal Info")

    RemovalsTab:CreateParagraph({
        Title = "Automatic Removal Features",
        Content = "Enable the toggles above to automatically delete EyepatchUI and WakeUpBlur. The system will continuously check and remove these elements as soon as they appear. Use the manual buttons for immediate removal."
    })

    -- Load configuration
    Rayfield:LoadConfiguration()

    -- Create FOV circle on startup
    createFOVCircle()
    FOVCircle.Visible = false

    -- Setup key listener
    setupKeyListener()

    -- Auto-create safe zone platform when script starts
    createSafeZonePlatform()

    print("Player & NPC Highlighter with Aimbot and Safe Zone Loaded!")
    print("NPC targeting: Now targets NPCs in workspace.Models folder")
    print("Aimbot Modes:")
    print("  - FOV Mode: Targets closest enemy within FOV circle")
    print("  - Nearest Target Mode: Targets closest enemy to you (anywhere)")
    print("  - Both modes require mouse inside FOV circle to aim")
end)

task.spawn(function()
    -- ============================================
    -- SCRIPT 2: INFINITE YIELD AND COMBAT UI
    -- ============================================
    
    -- Load Infinite Yield
    loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()

    -- ROBLOX LOCAL SCRIPT
    -- UPDATED: Simplified Ability Tab with Fixed Settings, Settings Save/Load, Scrollable UI
    -- Features: Auto-Block, Auto-Punch, Dash, Cam Lock, Cache, Ability Blocking

    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")
    local HttpService = game:GetService("HttpService")

    local Player = Players.LocalPlayer

    -- =================================================================================
    -- 1. CONFIG & DATABASE
    -- =================================================================================

    local m1Database = {
        -- Gojo
        ["127314304761047"] = true, ["77891317857963"] = true, ["84446039611604"] = true, ["114159183912233"] = true,
        -- Esper
        ["101101710876334"] = true, ["124127341057164"] = true, ["100901440555342"] = true, ["85853405255331"] = true,
        -- Mob
        ["85692420698843"] = true, ["75662531587920"] = true, ["130769245088771"] = true, ["103631040324206"] = true,
        -- Chara
        ["107867399798954"] = true, ["134486729011918"] = true, ["77034551070437"] = true, ["83150158223563"] = true,
        -- Godly
        ["136031609325321"] = true, ["120212532321192"] = true, ["74960987180381"] = true, ["122575871777232"] = true,
        -- Blade
        ["81483118494377"] = true, ["123762736246826"] = true, ["78443495730840"] = true, ["92893455375455"] = true,
        -- Kratos M1s
        ["130573375727993"] = true, ["114333120271557"] = true, ["131141291261313"] = true, ["70618047941591"] = true,
        ["110804273799167"] = true, ["124509785398074"] = true, ["88637553004334"] = true, ["113533567296840"] = true,
    }

    local dashStarts = {
        ["78290593213759"] = true, -- Gojo
        ["81171550723416"] = true, -- Esper
        ["16900584124"] = true,    -- Mob
        ["107027465005454"] = true, -- Chara
        ["104708203440312"] = true, -- Kratos Axe
        ["83008536875803"] = true,  -- Kratos Fist
        ["102141442579104"] = true, -- Godly
        ["134054487113051"] = true, -- Blade
        ["113533567296840"] = true, -- Extra Check
    }

    local dashEnds = {
        ["82190646305055"] = true, -- Gojo
        ["136991308458459"] = true, -- Esper
        ["16897565629"] = true,    -- Mob
        ["72484334716316"] = true,  -- Chara
        ["77242304295828"] = true,  -- Kratos Axe
        ["89684566192164"] = true,  -- Kratos Fist
        ["99230829853381"] = true,  -- Godly
        ["74672338436170"] = true,  -- Blade
    }

    -- Ability Database with Fixed Settings (New)
    local abilityDatabase = {
        -- Onslaught 1: Fixed settings as requested
        ["108015670641340"] = {
            Enabled = false,  -- Will be controlled by toggle
            Name = "Onslaught 1",
            Delay = 0.75,     -- Fixed delay
            Hold = 0.3,       -- Fixed hold
            Dist = 30,        -- Fixed distance
            Pred = 0,         -- Fixed prediction
            Chance = 1,       -- Fixed chance
            LookTime = 0.5,   -- From defaults
            PreDelay = 0.05,  -- From defaults
            PostDelay = 0.1,  -- From defaults
            Look = false,     -- Will be controlled by toggle
            Move = false,     -- Will be controlled by toggle
            Smart = false     -- Will be controlled by toggle
        },
        -- Onslaught 2: Fixed settings as requested
        ["119892721851554"] = {
            Enabled = false,  -- Will be controlled by toggle
            Name = "Onslaught 2",
            Delay = 0.75,     -- Fixed delay
            Hold = 0.3,       -- Fixed hold
            Dist = 30,        -- Fixed distance
            Pred = 0,         -- Fixed prediction
            Chance = 1,       -- Fixed chance
            LookTime = 0.5,   -- From defaults
            PreDelay = 0.05,  -- From defaults
            PostDelay = 0.1,  -- From defaults
            Look = false,     -- Will be controlled by toggle
            Move = false,     -- Will be controlled by toggle
            Smart = false     -- Will be controlled by toggle
        },
            -- ruthless beatdown
        ["18963762189"] = {
            Enabled = false,  -- Will be controlled by toggle
            Name = "ruthless beatdown",
            Delay = 0.2,     -- Fixed delay
            Hold = 0.3,       -- Fixed hold
            Dist = 30,        -- Fixed distance
            Pred = 0,         -- Fixed prediction
            Chance = 1,       -- Fixed chance
            LookTime = 0.5,   -- From defaults
            PreDelay = 0.05,  -- From defaults
            PostDelay = 0.1,  -- From defaults
            Look = false,     -- Will be controlled by toggle
            Move = false,     -- Will be controlled by toggle
            Smart = false     -- Will be controlled by toggle
        },
        -- 
        ["78096097412529"] = {
            Enabled = false,  -- Will be controlled by toggle
            Name = "ruthless kicks",
            Delay = 0.4,     -- Fixed delay
            Hold = 0.3,       -- Fixed hold
            Dist = 30,        -- Fixed distance
            Pred = 0,         -- Fixed prediction
            Chance = 1,       -- Fixed chance
            LookTime = 0.5,   -- From defaults
            PreDelay = 0.05,  -- From defaults
            PostDelay = 0.1,  -- From defaults
            Look = false,     -- Will be controlled by toggle
            Move = false,     -- Will be controlled by toggle
            Smart = false     -- Will be controlled by toggle
        },
        --  
        ["18879921457"] = {
            Enabled = false,  -- Will be controlled by toggle
            Name = "lapse pull",
            Delay = 0.1,     -- Fixed delay
            Hold = 0.5,       -- Fixed hold
            Dist = 30,        -- Fixed distance
            Pred = 0,         -- Fixed prediction
            Chance = 1,       -- Fixed chance
            LookTime = 0.5,   -- From defaults
            PreDelay = 0.05,  -- From defaults
            PostDelay = 0.1,  -- From defaults
            Look = false,     -- Will be controlled by toggle
            Move = false,     -- Will be controlled by toggle
            Smart = false     -- Will be controlled by toggle
        },
        -- 
        ["17328223121"] = {
            Enabled = false,  -- Will be controlled by toggle
            Name = "gojo grope",
            Delay = 0.2,     -- Fixed delay
            Hold = 0.3,       -- Fixed hold
            Dist = 30,        -- Fixed distance
            Pred = 0,         -- Fixed prediction
            Chance = 1,       -- Fixed chance
            LookTime = 0.5,   -- From defaults
            PreDelay = 0.05,  -- From defaults
            PostDelay = 0.1,  -- From defaults
            Look = false,     -- Will be controlled by toggle
            Move = false,     -- Will be controlled by toggle
            Smart = false     -- Will be controlled by toggle
        }
        -- Add more abilities here with their own fixed settings
    }

    local activeCharacters = {} 
    local processedTracks = {}

    -- Combo State
    local localComboCount = 0
    local lastLocalPunchTime = 0
    local comboCooldownActive = false

    -- Dash Animation
    local dashAnimRight = Instance.new("Animation"); dashAnimRight.AnimationId = "rbxassetid://16482641019"
    local dashAnimLeft = Instance.new("Animation"); dashAnimLeft.AnimationId = "rbxassetid://16482659401"

    -- CONTENT HEIGHT CONFIG (For Scrollbar)
    -- These numbers determine how far you can scroll on each tab
    local TAB_HEIGHTS = {
        Block = 550,
        Dash = 550,
        Punch = 500,
        Misc = 420,
        Abilities = 300 -- Reduced height for simplified tab
    }

    -- =================================================================================
    -- 2. REMOTE HANDLING
    -- =================================================================================

    local Remote = nil
    task.spawn(function()
        local success, result = pcall(function()
            return Player:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("AttackInput")
        end)
        if success then Remote = result end
    end)

    local function sendRemote(action, state)
        if not Remote then return end
        Remote:FireServer(action, state)
    end

    -- =================================================================================
    -- 3. SETTINGS SYSTEM
    -- =================================================================================

    -- Default settings structure
    local defaultSettings = {
        -- Block Settings
        Block = {
            Enabled = true,
            Look = false,
            Move = false,
            Caution = false,
            Delay = "0.16",
            Hold = "0.12",
            Dist = "10",
            Pred = "0",
            Chance = "1",
            LookTime = "0.5",
            PreDelay = "0.05",
            CautionDist = "15",
            CautionRate = "0.05"
        },
        -- Dash Settings
        Dash = {
            Enabled = true,
            Look = false,
            Move = false,
            Smart = false,
            Delay = "0.12",
            Hold = "0.1",
            Dist = "10",
            Pred = "0",
            Chance = "1",
            LookTime = "0.5",
            PreDelay = "0.05",
            PostDelay = "0.1"
        },
        -- Punch Settings
        Punch = {
            Enabled = false,
            Look = false,
            Glide = false,
            Max3 = false,
            Delay = "0.05",
            Hold = "0.1",
            Dist = "5",
            LookDist = "15",
            Chance = "1",
            LookTime = "0.35",
            ComboReset = "2"
        },
        -- Misc Settings
        Misc = {
            SideDash = false,
            CamLock = false,
            DashSpeed = "100",
            DashDecay = "0.3",
            DashCD = "2",
            CamSmooth = "0.1"
        },
        -- Ability Settings (Simplified - just toggles)
        Ability = {
            Enabled = false,
            Look = false,
            Move = false,
            Smart = false
        }
    }

    -- Load settings function
    local function loadSettings()
        local success, settingsData = pcall(function()
            -- Try to load from DataStoreService if available
            if getgenv().DataStoreService then
                local DataStoreService = getgenv().DataStoreService
                local dataStore = DataStoreService:GetDataStore("CombatUISettings")
                return dataStore:GetAsync(tostring(Player.UserId))
            end
            -- Fallback to writing file (for executors with file write access)
            if isfolder and isfolder("CombatUISettings") and isfile then
                local path = "CombatUISettings/" .. tostring(Player.UserId) .. ".json"
                if isfile(path) then
                    local file = readfile(path)
                    return HttpService:JSONDecode(file)
                end
            end
            return nil
        end)
        
        if success and settingsData then
            -- Merge loaded settings with defaults
            local loadedSettings = {}
            for category, defaultData in pairs(defaultSettings) do
                loadedSettings[category] = {}
                for key, defaultValue in pairs(defaultData) do
                    if settingsData[category] and settingsData[category][key] ~= nil then
                        loadedSettings[category][key] = settingsData[category][key]
                    else
                        loadedSettings[category][key] = defaultValue
                    end
                end
            end
            
            -- Also load ability database states if saved
            if settingsData.AbilityDatabase then
                for abilityId, abilityData in pairs(settingsData.AbilityDatabase) do
                    if abilityDatabase[abilityId] then
                        abilityDatabase[abilityId].Enabled = abilityData.Enabled or false
                        abilityDatabase[abilityId].Look = abilityData.Look or false
                        abilityDatabase[abilityId].Move = abilityData.Move or false
                        abilityDatabase[abilityId].Smart = abilityData.Smart or false
                    end
                end
            end
            
            return loadedSettings
        end
        return table.clone(defaultSettings)
    end

    -- Save settings function
    local function saveSettings(settingsToSave)
        local success = pcall(function()
            -- Also save ability database states
            settingsToSave.AbilityDatabase = {}
            for abilityId, abilityData in pairs(abilityDatabase) do
                settingsToSave.AbilityDatabase[abilityId] = {
                    Enabled = abilityData.Enabled,
                    Look = abilityData.Look,
                    Move = abilityData.Move,
                    Smart = abilityData.Smart
                }
            end
            
            -- Try to save to DataStoreService if available
            if getgenv().DataStoreService then
                local DataStoreService = getgenv().DataStoreService
                local dataStore = DataStoreService:GetDataStore("CombatUISettings")
                dataStore:SetAsync(tostring(Player.UserId), settingsToSave)
            end
            -- Fallback to writing file
            if makefolder and writefile then
                if not isfolder("CombatUISettings") then
                    makefolder("CombatUISettings")
                end
                local path = "CombatUISettings/" .. tostring(Player.UserId) .. ".json"
                writefile(path, HttpService:JSONEncode(settingsToSave))
            end
        end)
        return success
    end

    -- Initialize settings
    local settings = loadSettings()

    -- Apply loaded ability settings to ability database
    for abilityId, abilityData in pairs(abilityDatabase) do
        abilityData.Enabled = settings.Ability.Enabled or false
        abilityData.Look = settings.Ability.Look or false
        abilityData.Move = settings.Ability.Move or false
        abilityData.Smart = settings.Ability.Smart or false
    end

    -- =================================================================================
    -- 4. UI CONSTRUCTION
    -- =================================================================================

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "ModernCombatUI"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = Player:WaitForChild("PlayerGui")

    -- Tooltip
    local TooltipFrame = Instance.new("Frame")
    TooltipFrame.Name = "Tooltip"
    TooltipFrame.Size = UDim2.new(0, 200, 0, 0)
    TooltipFrame.AutomaticSize = Enum.AutomaticSize.Y
    TooltipFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    TooltipFrame.BorderSizePixel = 0
    TooltipFrame.Visible = false
    TooltipFrame.ZIndex = 200 
    TooltipFrame.Parent = ScreenGui

    local TTStroke = Instance.new("UIStroke", TooltipFrame)
    TTStroke.Color = Color3.fromRGB(60, 60, 70)
    TTStroke.Thickness = 1
    local TTCorner = Instance.new("UICorner", TooltipFrame)
    TTCorner.CornerRadius = UDim.new(0, 6)
    local TTLabel = Instance.new("TextLabel", TooltipFrame)
    TTLabel.Size = UDim2.new(1, -10, 0, 0)
    TTLabel.Position = UDim2.new(0, 5, 0, 5)
    TTLabel.AutomaticSize = Enum.AutomaticSize.Y
    TTLabel.BackgroundTransparency = 1
    TTLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9)
    TTLabel.Font = Enum.Font.Gotham
    TTLabel.TextSize = 11
    TTLabel.TextWrapped = true
    TTLabel.TextXAlignment = Enum.TextXAlignment.Left
    TTLabel.ZIndex = 201
    TTLabel.Parent = TooltipFrame
    local TTPadding = Instance.new("UIPadding", TooltipFrame)
    TTPadding.PaddingBottom = UDim.new(0, 5)

    -- Main Window (Fixed Height, Scrollable Content)
    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 280, 0, 450) -- Fixed height window
    MainFrame.Position = UDim2.new(0.1, 0, 0.2, 0)
    MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
    MainFrame.BorderSizePixel = 0
    MainFrame.Active = true
    MainFrame.ClipsDescendants = true
    MainFrame.Parent = ScreenGui

    local MainCorner = Instance.new("UICorner", MainFrame)
    MainCorner.CornerRadius = UDim.new(0, 10)
    local MainStroke = Instance.new("UIStroke", MainFrame)
    MainStroke.Color = Color3.fromRGB(50, 50, 60)
    MainStroke.Thickness = 2

    -- Drag Logic
    local dragging, dragInput, dragStart, startPos
    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true; dragStart = input.Position; startPos = MainFrame.Position
            input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
        end
    end)
    MainFrame.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    local function tween(obj, info, props) TweenService:Create(obj, TweenInfo.new(unpack(info)), props):Play() end

    local function registerTooltip(button, text)
        button.MouseEnter:Connect(function()
            TTLabel.Text = text
            TooltipFrame.Visible = true
            TooltipFrame.BackgroundTransparency = 1
            TTLabel.TextTransparency = 1
            tween(TooltipFrame, {0.2}, {BackgroundTransparency = 0.1})
            tween(TTLabel, {0.2}, {TextTransparency = 0})
        end)
        button.MouseMoved:Connect(function()
            local m = UserInputService:GetMouseLocation()
            TooltipFrame.Position = UDim2.fromOffset(m.X + 15, m.Y + 15)
        end)
        button.MouseLeave:Connect(function() TooltipFrame.Visible = false end)
    end

    local function createInput(parent, text, default, yPos)
        local Container = Instance.new("Frame", parent)
        Container.Size = UDim2.new(0.9, 0, 0, 30)
        Container.Position = UDim2.new(0.5, 0, 0, yPos)
        Container.AnchorPoint = Vector2.new(0.5, 0.5)
        Container.BackgroundTransparency = 1
        Container.ZIndex = 2
        Container:SetAttribute("OrgSize", Container.Size)

        local Label = Instance.new("TextLabel", Container)
        Label.Text = text
        Label.Size = UDim2.new(0.5, 0, 1, 0)
        Label.BackgroundTransparency = 1
        Label.TextColor3 = Color3.fromRGB(200, 200, 200)
        Label.TextXAlignment = Enum.TextXAlignment.Left
        Label.Font = Enum.Font.GothamMedium
        Label.TextSize = 12
        Label.ZIndex = 2

        local Box = Instance.new("TextBox", Container)
        Box.Text = default
        Box.Size = UDim2.new(0.45, 0, 1, 0)
        Box.Position = UDim2.new(0.55, 0, 0, 0)
        Box.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        Box.TextColor3 = Color3.fromRGB(100, 255, 120)
        Box.Font = Enum.Font.Code
        Box.TextSize = 12
        Box.ZIndex = 2
        
        local Corner = Instance.new("UICorner", Box); Corner.CornerRadius = UDim.new(0, 6)
        return Box, Container
    end

    local function createToggle(parent, text, yPos)
        local Btn = Instance.new("TextButton", parent)
        Btn.Text = text
        Btn.Size = UDim2.new(0.9, 0, 0, 35)
        Btn.Position = UDim2.new(0.5, 0, 0, yPos)
        Btn.AnchorPoint = Vector2.new(0.5, 0.5)
        Btn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
        Btn.TextColor3 = Color3.new(1, 1, 1)
        Btn.Font = Enum.Font.GothamBold
        Btn.TextSize = 14
        Btn.ZIndex = 2
        Btn:SetAttribute("OrgSize", Btn.Size)
        Btn:SetAttribute("BaseColor", Btn.BackgroundColor3) 
        local Corner = Instance.new("UICorner", Btn); Corner.CornerRadius = UDim.new(0, 6)
        
        -- Hover Effect
        Btn.MouseEnter:Connect(function()
            local curr = Btn.BackgroundColor3
            tween(Btn, {0.2, Enum.EasingStyle.Quad}, {BackgroundColor3 = Color3.new(math.min(curr.R+0.1,1), math.min(curr.G+0.1,1), math.min(curr.B+0.1,1))})
        end)
        Btn.MouseLeave:Connect(function()
            tween(Btn, {0.2, Enum.EasingStyle.Quad}, {BackgroundColor3 = Btn:GetAttribute("BaseColor")})
        end)
        
        return Btn
    end

    -- =================================================================================
    -- 5. PAGE CONTENT & SCROLLING
    -- =================================================================================

    local TabFrame = Instance.new("Frame", MainFrame)
    TabFrame.Size = UDim2.new(1, -10, 0, 40)
    TabFrame.Position = UDim2.new(0.5, 0, 0, 5)
    TabFrame.AnchorPoint = Vector2.new(0.5, 0)
    TabFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
    TabFrame.ZIndex = 10
    local TabCorner = Instance.new("UICorner", TabFrame); TabCorner.CornerRadius = UDim.new(0, 8)

    -- Adjust tab sizes for 5 tabs
    local function createTabBtn(text, xOrder)
        local btn = Instance.new("TextButton", TabFrame)
        btn.Size = UDim2.new(0.2, 0, 1, 0) -- Changed from 0.25 to 0.2 for 5 tabs
        btn.Position = UDim2.new(0.2 * (xOrder-1), 0, 0, 0) -- Changed from 0.25 to 0.2
        btn.Text = text
        btn.BackgroundTransparency = 1
        btn.TextColor3 = Color3.fromRGB(150,150,150)
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 11
        btn.ZIndex = 11
        return btn
    end

    local BlockTabBtn = createTabBtn("BLOCK", 1); BlockTabBtn.TextColor3 = Color3.new(1,1,1)
    local DashTabBtn = createTabBtn("DASH", 2)
    local PunchTabBtn = createTabBtn("PUNCH", 3)
    local MiscTabBtn = createTabBtn("MISC", 4)
    local AbilityTabBtn = createTabBtn("ABILITY", 5) -- New tab

    local TabIndicator = Instance.new("Frame", TabFrame)
    TabIndicator.Size = UDim2.new(0.2, -4, 0, 3) -- Changed from 0.25 to 0.2
    TabIndicator.Position = UDim2.new(0, 2, 1, -3)
    TabIndicator.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
    TabIndicator.BorderSizePixel = 0
    TabIndicator.ZIndex = 12
    local IndCorner = Instance.new("UICorner", TabIndicator); IndCorner.CornerRadius = UDim.new(1, 0)

    -- SCROLLING CONTAINER
    local ScrollContainer = Instance.new("ScrollingFrame", MainFrame)
    ScrollContainer.Size = UDim2.new(1, 0, 1, -50)
    ScrollContainer.Position = UDim2.new(0, 0, 0, 50)
    ScrollContainer.BackgroundTransparency = 1
    ScrollContainer.BorderSizePixel = 0
    ScrollContainer.ScrollBarThickness = 4
    ScrollContainer.ScrollBarImageColor3 = Color3.fromRGB(80, 200, 120)
    ScrollContainer.ClipsDescendants = true -- Ensures elements hide when scrolled/switched
    ScrollContainer.CanvasSize = UDim2.new(0, 0, 0, 550) -- Dynamic

    -- Pages
    local BlockPage = Instance.new("Frame", ScrollContainer); BlockPage.Size = UDim2.new(1, 0, 1, 0); BlockPage.BackgroundTransparency = 1; BlockPage.Visible = true; BlockPage.Name = "BlockPage"
    local DashPage = Instance.new("Frame", ScrollContainer); DashPage.Size = UDim2.new(1, 0, 1, 0); DashPage.BackgroundTransparency = 1; DashPage.Visible = false; DashPage.Name = "DashPage"
    local PunchPage = Instance.new("Frame", ScrollContainer); PunchPage.Size = UDim2.new(1, 0, 1, 0); PunchPage.BackgroundTransparency = 1; PunchPage.Visible = false; PunchPage.Name = "PunchPage"
    local MiscPage = Instance.new("Frame", ScrollContainer); MiscPage.Size = UDim2.new(1, 0, 1, 0); MiscPage.BackgroundTransparency = 1; MiscPage.Visible = false; MiscPage.Name = "MiscPage"
    local AbilityPage = Instance.new("Frame", ScrollContainer); AbilityPage.Size = UDim2.new(1, 0, 1, 0); AbilityPage.BackgroundTransparency = 1; AbilityPage.Visible = false; AbilityPage.Name = "AbilityPage" -- New page

    local StatusLabel = Instance.new("TextLabel", MainFrame)
    StatusLabel.Text = "IDLE"
    StatusLabel.Size = UDim2.new(1, 0, 0, 20)
    StatusLabel.Position = UDim2.new(0, 0, 1, -15)
    StatusLabel.BackgroundTransparency = 1
    StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
    StatusLabel.Font = Enum.Font.Code
    StatusLabel.TextSize = 10
    StatusLabel.ZIndex = 20

    -- == BLOCK PAGE CONTENTS ==
    local B_Delay, c1 = createInput(BlockPage, "Delay (s):", settings.Block.Delay, 30)
    local B_Hold, c2 = createInput(BlockPage, "Hold (s):", settings.Block.Hold, 70)
    local B_Dist, c3 = createInput(BlockPage, "Distance:", settings.Block.Dist, 110)
    local B_Pred, c3b = createInput(BlockPage, "Prediction:", settings.Block.Pred, 150)
    local B_Chance, c4 = createInput(BlockPage, "Chance (0-1):", settings.Block.Chance, 190)
    local B_LookTime, c5 = createInput(BlockPage, "Look Time (s):", settings.Block.LookTime, 230)
    local B_PreDelay, c6 = createInput(BlockPage, "Look Ahead (s):", settings.Block.PreDelay, 270)
    local B_CautionDist, c7 = createInput(BlockPage, "Cautious Dist:", settings.Block.CautionDist, 310)
    local B_CautionRate, c8 = createInput(BlockPage, "Cautious Rate:", settings.Block.CautionRate, 350)

    local B_Toggle = createToggle(BlockPage, "Block: ON", 400)
    B_Toggle.BackgroundColor3 = settings.Block.Enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    B_Toggle:SetAttribute("BaseColor", B_Toggle.BackgroundColor3)
    registerTooltip(B_Toggle, "Auto-Blocks M1 Attacks.")

    local B_LookToggle = createToggle(BlockPage, "Look At: OFF", 440)
    B_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
    B_LookToggle.BackgroundColor3 = settings.Block.Look and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    B_LookToggle:SetAttribute("BaseColor", B_LookToggle.BackgroundColor3)
    registerTooltip(B_LookToggle, "Faces the enemy BEFORE blocking.")

    local B_MoveToggle = createToggle(BlockPage, "Auto Pos: OFF", 470)
    B_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25)
    B_MoveToggle.BackgroundColor3 = settings.Block.Move and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    B_MoveToggle:SetAttribute("BaseColor", B_MoveToggle.BackgroundColor3)
    registerTooltip(B_MoveToggle, "Instantly glides 3 studs in front of the attacker.")

    local B_CautionToggle = createToggle(BlockPage, "Cautious: OFF", 500)
    B_CautionToggle.Size = UDim2.new(0.9, 0, 0, 25)
    B_CautionToggle.BackgroundColor3 = settings.Block.Caution and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    B_CautionToggle:SetAttribute("BaseColor", B_CautionToggle.BackgroundColor3)
    registerTooltip(B_CautionToggle, "Randomly blocks/stares to look human.")

    -- == DASH PAGE CONTENTS ==
    local D_Delay = createInput(DashPage, "Delay (s):", settings.Dash.Delay, 30)
    local D_Hold = createInput(DashPage, "Hold (s):", settings.Dash.Hold, 70)
    local D_Dist = createInput(DashPage, "Distance:", settings.Dash.Dist, 110)
    local D_Pred = createInput(DashPage, "Prediction:", settings.Dash.Pred, 150)
    local D_Chance = createInput(DashPage, "Chance (0-1):", settings.Dash.Chance, 190)
    local D_LookTime = createInput(DashPage, "Look Time (s):", settings.Dash.LookTime, 230)
    local D_PreDelay = createInput(DashPage, "Look Ahead (s):", settings.Dash.PreDelay, 270)
    local D_PostDelay = createInput(DashPage, "Post-Anim (s):", settings.Dash.PostDelay, 310)

    local D_Toggle = createToggle(DashPage, "Dash Block: ON", 360)
    D_Toggle.BackgroundColor3 = settings.Dash.Enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    D_Toggle:SetAttribute("BaseColor", D_Toggle.BackgroundColor3)
    registerTooltip(D_Toggle, "Auto-Blocks Dash Attacks.")

    local D_SmartToggle = createToggle(DashPage, "Smart Hold: OFF", 400)
    D_SmartToggle.Size = UDim2.new(0.9, 0, 0, 25)
    D_SmartToggle.BackgroundColor3 = settings.Dash.Smart and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    D_SmartToggle:SetAttribute("BaseColor", D_SmartToggle.BackgroundColor3)
    registerTooltip(D_SmartToggle, "Waits for 'End/Punch' anim to START, then waits Post-Anim to unblock.")

    local D_LookToggle = createToggle(DashPage, "Look At: OFF", 430)
    D_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
    D_LookToggle.BackgroundColor3 = settings.Dash.Look and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    D_LookToggle:SetAttribute("BaseColor", D_LookToggle.BackgroundColor3)
    registerTooltip(D_LookToggle, "Faces the enemy BEFORE blocking dash.")

    local D_MoveToggle = createToggle(DashPage, "Auto Pos: OFF", 460)
    D_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25)
    D_MoveToggle.BackgroundColor3 = settings.Dash.Move and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    D_MoveToggle:SetAttribute("BaseColor", D_MoveToggle.BackgroundColor3)
    registerTooltip(D_MoveToggle, "Instantly glides 3 studs in front of dash attacker.")

    -- == PUNCH PAGE CONTENTS ==
    local P_Delay, p1 = createInput(PunchPage, "Delay (s):", settings.Punch.Delay, 30)
    local P_Hold, p2 = createInput(PunchPage, "Hold (s):", settings.Punch.Hold, 70)
    local P_Dist, p3 = createInput(PunchPage, "Atk Dist:", settings.Punch.Dist, 110)
    local P_LookDist, p3b = createInput(PunchPage, "Look Dist:", settings.Punch.LookDist, 150)
    local P_Chance, p4 = createInput(PunchPage, "Chance (0-1):", settings.Punch.Chance, 190)
    local P_LookTime, p5 = createInput(PunchPage, "Look Time (s):", settings.Punch.LookTime, 230)
    local P_ComboReset, p6 = createInput(PunchPage, "Cooldown (s):", settings.Punch.ComboReset, 270)

    local P_Toggle = createToggle(PunchPage, "Punch: OFF", 320)
    P_Toggle.BackgroundColor3 = settings.Punch.Enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    P_Toggle:SetAttribute("BaseColor", P_Toggle.BackgroundColor3)
    registerTooltip(P_Toggle, "Block ON: Counter-Attack mode.\nBlock OFF: Aggro mode.")

    local P_LookToggle = createToggle(PunchPage, "Look At: OFF", 360)
    P_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
    P_LookToggle.BackgroundColor3 = settings.Punch.Look and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    P_LookToggle:SetAttribute("BaseColor", P_LookToggle.BackgroundColor3)
    registerTooltip(P_LookToggle, "Locks rotation onto the target while punching.")

    local P_GlideToggle = createToggle(PunchPage, "Glide: OFF", 390)
    P_GlideToggle.Size = UDim2.new(0.9, 0, 0, 25)
    P_GlideToggle.BackgroundColor3 = settings.Punch.Glide and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    P_GlideToggle:SetAttribute("BaseColor", P_GlideToggle.BackgroundColor3)
    registerTooltip(P_GlideToggle, "Smoothly moves closer to the target while punching.")

    local P_ComboToggle = createToggle(PunchPage, "Max 3 Hits: OFF", 420)
    P_ComboToggle.Size = UDim2.new(0.9, 0, 0, 25)
    P_ComboToggle.BackgroundColor3 = settings.Punch.Max3 and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    P_ComboToggle:SetAttribute("BaseColor", P_ComboToggle.BackgroundColor3)
    registerTooltip(P_ComboToggle, "Stops punching after 3 consecutive M1s detected on yourself.")

    -- == MISC PAGE CONTENTS ==
    local M_DashSpeed, m1 = createInput(MiscPage, "Dash Speed:", settings.Misc.DashSpeed, 30)
    local M_DashDecay, m2 = createInput(MiscPage, "Dash Decay (s):", settings.Misc.DashDecay, 70)
    local M_DashCD, m3 = createInput(MiscPage, "Dash CD (s):", settings.Misc.DashCD, 110)
    local M_CamSmooth, m4 = createInput(MiscPage, "Cam Smooth:", settings.Misc.CamSmooth, 150)

    local M_SideDashToggle = createToggle(MiscPage, "Side Dash: OFF", 200)
    M_SideDashToggle.Size = UDim2.new(0.9, 0, 0, 30)
    M_SideDashToggle.BackgroundColor3 = settings.Misc.SideDash and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    M_SideDashToggle:SetAttribute("BaseColor", M_SideDashToggle.BackgroundColor3)
    registerTooltip(M_SideDashToggle, "Aggro Mode: Dashes L/R around enemy.")

    local M_CamLockToggle = createToggle(MiscPage, "Cam Lock: OFF", 240)
    M_CamLockToggle.Size = UDim2.new(0.9, 0, 0, 30)
    M_CamLockToggle.BackgroundColor3 = settings.Misc.CamLock and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    M_CamLockToggle:SetAttribute("BaseColor", M_CamLockToggle.BackgroundColor3)
    registerTooltip(M_CamLockToggle, "Guides camera to target.")

    -- Add Save/Load buttons to Misc page
    local SaveSettingsBtn = createToggle(MiscPage, "Save Settings", 280)
    SaveSettingsBtn.Size = UDim2.new(0.9, 0, 0, 30)
    SaveSettingsBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 200)
    SaveSettingsBtn:SetAttribute("BaseColor", SaveSettingsBtn.BackgroundColor3)
    registerTooltip(SaveSettingsBtn, "Save all current settings to disk.")

    local LoadSettingsBtn = createToggle(MiscPage, "Load Settings", 320)
    LoadSettingsBtn.Size = UDim2.new(0.9, 0, 0, 30)
    LoadSettingsBtn.BackgroundColor3 = Color3.fromRGB(70, 200, 130)
    LoadSettingsBtn:SetAttribute("BaseColor", LoadSettingsBtn.BackgroundColor3)
    registerTooltip(LoadSettingsBtn, "Load saved settings from disk.")

    local ResetSettingsBtn = createToggle(MiscPage, "Reset to Defaults", 360)
    ResetSettingsBtn.Size = UDim2.new(0.9, 0, 0, 30)
    ResetSettingsBtn.BackgroundColor3 = Color3.fromRGB(200, 130, 70)
    ResetSettingsBtn:SetAttribute("BaseColor", ResetSettingsBtn.BackgroundColor3)
    registerTooltip(ResetSettingsBtn, "Reset all settings to default values.")

    -- == ABILITY PAGE CONTENTS (SIMPLIFIED - NO EDITABLE SETTINGS) ==
    -- Master toggle for all abilities
    local A_MasterToggle = createToggle(AbilityPage, "Abilities: OFF", 30)
    A_MasterToggle.BackgroundColor3 = settings.Ability.Enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    A_MasterToggle:SetAttribute("BaseColor", A_MasterToggle.BackgroundColor3)
    registerTooltip(A_MasterToggle, "Toggle ALL ability blocking on/off.")

    -- Individual ability toggles (for future expansion)
    local A_LookToggle = createToggle(AbilityPage, "Look At: OFF", 80)
    A_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
    A_LookToggle.BackgroundColor3 = settings.Ability.Look and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    A_LookToggle:SetAttribute("BaseColor", A_LookToggle.BackgroundColor3)
    registerTooltip(A_LookToggle, "Faces the enemy BEFORE blocking abilities.")

    local A_MoveToggle = createToggle(AbilityPage, "Auto Pos: OFF", 115)
    A_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25)
    A_MoveToggle.BackgroundColor3 = settings.Ability.Move and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    A_MoveToggle:SetAttribute("BaseColor", A_MoveToggle.BackgroundColor3)
    registerTooltip(A_MoveToggle, "Instantly glides 3 studs in front of ability attacker.")

    local A_SmartToggle = createToggle(AbilityPage, "Smart Hold: OFF", 150)
    A_SmartToggle.Size = UDim2.new(0.9, 0, 0, 25)
    A_SmartToggle.BackgroundColor3 = settings.Ability.Smart and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
    A_SmartToggle:SetAttribute("BaseColor", A_SmartToggle.BackgroundColor3)
    registerTooltip(A_SmartToggle, "Waits for ability animation to complete before unblocking.")

    -- Ability Info Display
    local AbilityInfoLabel = Instance.new("TextLabel", AbilityPage)
    AbilityInfoLabel.Text = "Fixed Settings for Abilities:"
    AbilityInfoLabel.Size = UDim2.new(0.9, 0, 0, 20)
    AbilityInfoLabel.Position = UDim2.new(0.5, 0, 0, 185)
    AbilityInfoLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    AbilityInfoLabel.BackgroundTransparency = 1
    AbilityInfoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    AbilityInfoLabel.Font = Enum.Font.GothamMedium
    AbilityInfoLabel.TextSize = 12
    AbilityInfoLabel.TextXAlignment = Enum.TextXAlignment.Left

    local AbilityInfoText = Instance.new("TextLabel", AbilityPage)
    AbilityInfoText.Text = " Onslaught 1 & 2:\n  Delay: 0.75s | Hold: 0.3s\n  Distance: 30 | Prediction: 0\n  Chance: 100%"
    AbilityInfoText.Size = UDim2.new(0.9, 0, 0, 80)
    AbilityInfoText.Position = UDim2.new(0.5, 0, 0, 210)
    AbilityInfoText.AnchorPoint = Vector2.new(0.5, 0.5)
    AbilityInfoText.BackgroundTransparency = 1
    AbilityInfoText.TextColor3 = Color3.fromRGB(100, 255, 120)
    AbilityInfoText.Font = Enum.Font.Code
    AbilityInfoText.TextSize = 11
    AbilityInfoText.TextXAlignment = Enum.TextXAlignment.Left
    AbilityInfoText.TextYAlignment = Enum.TextYAlignment.Top
    AbilityInfoText.TextWrapped = true

    -- =================================================================================
    -- 6. TRANSITION & HIDING LOGIC (Fixed)
    -- =================================================================================

    local currentTab = "Block" 
    local transitionID = 0 -- Prevents async overlap glitches

    local function getElements(page)
        local elements = {}
        for _, child in pairs(page:GetChildren()) do
            if child:IsA("GuiObject") then table.insert(elements, child) end
        end
        return elements
    end

    local function animateOut(page)
        local elements = getElements(page)
        for _, el in pairs(elements) do
            -- Store original pos
            if not el:GetAttribute("OrgPos") then
                el:SetAttribute("OrgPos", el.Position)
                el:SetAttribute("OrgSize", el.Size)
            end
            
            -- "Explode" effect
            local rotDir = math.random(0, 1) == 1 and 1 or -1
            local tweenGoals = { Rotation = 180 * rotDir, Size = UDim2.new(0,0,0,0), BackgroundTransparency = 1 }
            
            if el:IsA("TextLabel") or el:IsA("TextButton") or el:IsA("TextBox") then tweenGoals.TextTransparency = 1 end
            tween(el, {0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In}, tweenGoals)
            
            -- Fade children
            for _, sub in pairs(el:GetDescendants()) do
                if sub:IsA("TextLabel") or sub:IsA("TextBox") or sub:IsA("TextButton") then
                    tween(sub, {0.3}, {TextTransparency = 1, BackgroundTransparency = 1})
                end
            end
        end
    end

    local function animateIn(page)
        page.Visible = true 
        local elements = getElements(page)
        for _, el in pairs(elements) do
            local orgPos = el:GetAttribute("OrgPos") or el.Position
            local orgSize = el:GetAttribute("OrgSize") or el.Size
            el:SetAttribute("OrgPos", orgPos)
            
            -- Set Start State
            el.Rotation = math.random(-90, 90)
            el.Size = UDim2.new(0, 0, 0, 0) 
            el.BackgroundTransparency = 1
            
            -- Prepare Tweens
            local endTransparency = (el:IsA("TextButton") or el:IsA("TextBox")) and 0 or 1
            local tweenGoals = { Rotation = 0, Size = orgSize, BackgroundTransparency = endTransparency }
            
            if el:IsA("TextButton") or el:IsA("TextLabel") or el:IsA("TextBox") then tweenGoals.TextTransparency = 0 end
            tween(el, {0.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out}, tweenGoals)
            
            -- Fade In children
            for _, sub in pairs(el:GetDescendants()) do
                if sub:IsA("TextLabel") or sub:IsA("TextBox") or sub:IsA("TextButton") then
                    tween(sub, {0.3}, {TextTransparency = 0})
                    if sub:IsA("TextBox") then tween(sub, {0.3}, {BackgroundTransparency = 0}) end
                end
            end
        end
    end

    local function switchTab(tabName, btn, indicatorPos, contentHeight)
        if currentTab == tabName then return end
        currentTab = tabName
        transitionID = transitionID + 1
        local currentID = transitionID
        
        -- Colors
        tween(BlockTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
        tween(DashTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
        tween(PunchTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
        tween(MiscTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
        tween(AbilityTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
        tween(btn, {0.3}, {TextColor3 = Color3.new(1,1,1)})
        tween(TabIndicator, {0.3, Enum.EasingStyle.Back}, {Position = indicatorPos})
        
        -- Update Scrolling Canvas
        ScrollContainer.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
        
        -- Clean Up Old
        animateOut(BlockPage)
        animateOut(DashPage)
        animateOut(PunchPage)
        animateOut(MiscPage)
        animateOut(AbilityPage)
        
        -- Bring In New
        if tabName == "Block" then animateIn(BlockPage)
        elseif tabName == "Dash" then animateIn(DashPage)
        elseif tabName == "Punch" then animateIn(PunchPage)
        elseif tabName == "Misc" then animateIn(MiscPage)
        elseif tabName == "Abilities" then animateIn(AbilityPage)
        end
        
        -- Force Hide logic to prevent overlaps
        task.delay(0.4, function()
            if transitionID ~= currentID then return end -- If user switched again, don't touch
            BlockPage.Visible = (tabName == "Block")
            DashPage.Visible = (tabName == "Dash")
            PunchPage.Visible = (tabName == "Punch")
            MiscPage.Visible = (tabName == "Misc")
            AbilityPage.Visible = (tabName == "Abilities")
        end)
    end

    BlockTabBtn.MouseButton1Click:Connect(function() switchTab("Block", BlockTabBtn, UDim2.new(0, 2, 1, -3), TAB_HEIGHTS.Block) end)
    DashTabBtn.MouseButton1Click:Connect(function() switchTab("Dash", DashTabBtn, UDim2.new(0.2, 2, 1, -3), TAB_HEIGHTS.Dash) end)
    PunchTabBtn.MouseButton1Click:Connect(function() switchTab("Punch", PunchTabBtn, UDim2.new(0.4, 2, 1, -3), TAB_HEIGHTS.Punch) end)
    MiscTabBtn.MouseButton1Click:Connect(function() switchTab("Misc", MiscTabBtn, UDim2.new(0.6, 2, 1, -3), TAB_HEIGHTS.Misc) end)
    AbilityTabBtn.MouseButton1Click:Connect(function() switchTab("Abilities", AbilityTabBtn, UDim2.new(0.8, 2, 1, -3), TAB_HEIGHTS.Abilities) end)

    -- =================================================================================
    -- 7. TOGGLE LOGIC
    -- =================================================================================

    local function updateToggleVisuals(btn, enabled, textOn, textOff)
        local newColor = enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
        btn.Text = enabled and textOn or textOff
        btn:SetAttribute("BaseColor", newColor) 
        tween(btn, {0.2}, {BackgroundColor3 = newColor})
    end

    -- Function to collect all current settings from UI
    local function collectCurrentSettings()
        local currentSettings = table.clone(defaultSettings)
        
        -- Block settings
        currentSettings.Block.Enabled = settings.Block.Enabled
        currentSettings.Block.Look = settings.Block.Look
        currentSettings.Block.Move = settings.Block.Move
        currentSettings.Block.Caution = settings.Block.Caution
        currentSettings.Block.Delay = B_Delay.Text
        currentSettings.Block.Hold = B_Hold.Text
        currentSettings.Block.Dist = B_Dist.Text
        currentSettings.Block.Pred = B_Pred.Text
        currentSettings.Block.Chance = B_Chance.Text
        currentSettings.Block.LookTime = B_LookTime.Text
        currentSettings.Block.PreDelay = B_PreDelay.Text
        currentSettings.Block.CautionDist = B_CautionDist.Text
        currentSettings.Block.CautionRate = B_CautionRate.Text
        
        -- Dash settings
        currentSettings.Dash.Enabled = settings.Dash.Enabled
        currentSettings.Dash.Look = settings.Dash.Look
        currentSettings.Dash.Move = settings.Dash.Move
        currentSettings.Dash.Smart = settings.Dash.Smart
        currentSettings.Dash.Delay = D_Delay.Text
        currentSettings.Dash.Hold = D_Hold.Text
        currentSettings.Dash.Dist = D_Dist.Text
        currentSettings.Dash.Pred = D_Pred.Text
        currentSettings.Dash.Chance = D_Chance.Text
        currentSettings.Dash.LookTime = D_LookTime.Text
        currentSettings.Dash.PreDelay = D_PreDelay.Text
        currentSettings.Dash.PostDelay = D_PostDelay.Text
        
        -- Punch settings
        currentSettings.Punch.Enabled = settings.Punch.Enabled
        currentSettings.Punch.Look = settings.Punch.Look
        currentSettings.Punch.Glide = settings.Punch.Glide
        currentSettings.Punch.Max3 = settings.Punch.Max3
        currentSettings.Punch.Delay = P_Delay.Text
        currentSettings.Punch.Hold = P_Hold.Text
        currentSettings.Punch.Dist = P_Dist.Text
        currentSettings.Punch.LookDist = P_LookDist.Text
        currentSettings.Punch.Chance = P_Chance.Text
        currentSettings.Punch.LookTime = P_LookTime.Text
        currentSettings.Punch.ComboReset = P_ComboReset.Text
        
        -- Misc settings
        currentSettings.Misc.SideDash = settings.Misc.SideDash
        currentSettings.Misc.CamLock = settings.Misc.CamLock
        currentSettings.Misc.DashSpeed = M_DashSpeed.Text
        currentSettings.Misc.DashDecay = M_DashDecay.Text
        currentSettings.Misc.DashCD = M_DashCD.Text
        currentSettings.Misc.CamSmooth = M_CamSmooth.Text
        
        -- Ability settings (Simplified)
        currentSettings.Ability.Enabled = settings.Ability.Enabled
        currentSettings.Ability.Look = settings.Ability.Look
        currentSettings.Ability.Move = settings.Ability.Move
        currentSettings.Ability.Smart = settings.Ability.Smart
        
        return currentSettings
    end

    -- Function to apply settings to UI
    local function applySettings(newSettings)
        settings = table.clone(newSettings)
        
        -- Apply toggles
        updateToggleVisuals(B_Toggle, settings.Block.Enabled, "Block: ON", "Block: OFF")
        updateToggleVisuals(B_LookToggle, settings.Block.Look, "Look At: ON", "Look At: OFF")
        updateToggleVisuals(B_MoveToggle, settings.Block.Move, "Auto Pos: ON", "Auto Pos: OFF")
        updateToggleVisuals(B_CautionToggle, settings.Block.Caution, "Cautious: ON", "Cautious: OFF")
        
        updateToggleVisuals(D_Toggle, settings.Dash.Enabled, "Dash Block: ON", "Dash Block: OFF")
        updateToggleVisuals(D_LookToggle, settings.Dash.Look, "Look At: ON", "Look At: OFF")
        updateToggleVisuals(D_MoveToggle, settings.Dash.Move, "Auto Pos: ON", "Auto Pos: OFF")
        updateToggleVisuals(D_SmartToggle, settings.Dash.Smart, "Smart Hold: ON", "Smart Hold: OFF")
        
        updateToggleVisuals(P_Toggle, settings.Punch.Enabled, "Punch: ON", "Punch: OFF")
        updateToggleVisuals(P_LookToggle, settings.Punch.Look, "Look At: ON", "Look At: OFF")
        updateToggleVisuals(P_GlideToggle, settings.Punch.Glide, "Glide: ON", "Glide: OFF")
        updateToggleVisuals(P_ComboToggle, settings.Punch.Max3, "Max 3 Hits: ON", "Max 3 Hits: OFF")
        
        updateToggleVisuals(M_SideDashToggle, settings.Misc.SideDash, "Side Dash: ON", "Side Dash: OFF")
        updateToggleVisuals(M_CamLockToggle, settings.Misc.CamLock, "Cam Lock: ON", "Cam Lock: OFF")
        
        -- Apply ability toggles (Simplified)
        updateToggleVisuals(A_MasterToggle, settings.Ability.Enabled, "Abilities: ON", "Abilities: OFF")
        updateToggleVisuals(A_LookToggle, settings.Ability.Look, "Look At: ON", "Look At: OFF")
        updateToggleVisuals(A_MoveToggle, settings.Ability.Move, "Auto Pos: ON", "Auto Pos: OFF")
        updateToggleVisuals(A_SmartToggle, settings.Ability.Smart, "Smart Hold: ON", "Smart Hold: OFF")
        
        -- Apply ability settings to ability database
        for abilityId, abilityData in pairs(abilityDatabase) do
            abilityData.Enabled = settings.Ability.Enabled
            abilityData.Look = settings.Ability.Look
            abilityData.Move = settings.Ability.Move
            abilityData.Smart = settings.Ability.Smart
        end
        
        -- Apply textbox values
        B_Delay.Text = settings.Block.Delay
        B_Hold.Text = settings.Block.Hold
        B_Dist.Text = settings.Block.Dist
        B_Pred.Text = settings.Block.Pred
        B_Chance.Text = settings.Block.Chance
        B_LookTime.Text = settings.Block.LookTime
        B_PreDelay.Text = settings.Block.PreDelay
        B_CautionDist.Text = settings.Block.CautionDist
        B_CautionRate.Text = settings.Block.CautionRate
        
        D_Delay.Text = settings.Dash.Delay
        D_Hold.Text = settings.Dash.Hold
        D_Dist.Text = settings.Dash.Dist
        D_Pred.Text = settings.Dash.Pred
        D_Chance.Text = settings.Dash.Chance
        D_LookTime.Text = settings.Dash.LookTime
        D_PreDelay.Text = settings.Dash.PreDelay
        D_PostDelay.Text = settings.Dash.PostDelay
        
        P_Delay.Text = settings.Punch.Delay
        P_Hold.Text = settings.Punch.Hold
        P_Dist.Text = settings.Punch.Dist
        P_LookDist.Text = settings.Punch.LookDist
        P_Chance.Text = settings.Punch.Chance
        P_LookTime.Text = settings.Punch.LookTime
        P_ComboReset.Text = settings.Punch.ComboReset
        
        M_DashSpeed.Text = settings.Misc.DashSpeed
        M_DashDecay.Text = settings.Misc.DashDecay
        M_DashCD.Text = settings.Misc.DashCD
        M_CamSmooth.Text = settings.Misc.CamSmooth
    end

    -- Save settings function
    SaveSettingsBtn.MouseButton1Click:Connect(function()
        local currentSettings = collectCurrentSettings()
        local success = saveSettings(currentSettings)
        
        if success then
            StatusLabel.Text = "SETTINGS SAVED"
            StatusLabel.TextColor3 = Color3.fromRGB(80, 255, 120)
            task.delay(2, function()
                StatusLabel.Text = "IDLE"
                StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
            end)
        else
            StatusLabel.Text = "SAVE FAILED"
            StatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            task.delay(2, function()
                StatusLabel.Text = "IDLE"
                StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
            end)
        end
    end)

    -- Load settings function
    LoadSettingsBtn.MouseButton1Click:Connect(function()
        local loadedSettings = loadSettings()
        applySettings(loadedSettings)
        
        StatusLabel.Text = "SETTINGS LOADED"
        StatusLabel.TextColor3 = Color3.fromRGB(80, 255, 120)
        task.delay(2, function()
            StatusLabel.Text = "IDLE"
            StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
        end)
    end)

    -- Reset settings function
    ResetSettingsBtn.MouseButton1Click:Connect(function()
        applySettings(table.clone(defaultSettings))
        
        StatusLabel.Text = "SETTINGS RESET"
        StatusLabel.TextColor3 = Color3.fromRGB(255, 200, 50)
        task.delay(2, function()
            StatusLabel.Text = "IDLE"
            StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
        end)
    end)

    -- Toggle Connections
    B_Toggle.MouseButton1Click:Connect(function() settings.Block.Enabled = not settings.Block.Enabled; updateToggleVisuals(B_Toggle, settings.Block.Enabled, "Block: ON", "Block: OFF") end)
    B_LookToggle.MouseButton1Click:Connect(function() settings.Block.Look = not settings.Block.Look; updateToggleVisuals(B_LookToggle, settings.Block.Look, "Look At: ON", "Look At: OFF") end)
    B_MoveToggle.MouseButton1Click:Connect(function() settings.Block.Move = not settings.Block.Move; updateToggleVisuals(B_MoveToggle, settings.Block.Move, "Auto Pos: ON", "Auto Pos: OFF") end)
    B_CautionToggle.MouseButton1Click:Connect(function() settings.Block.Caution = not settings.Block.Caution; updateToggleVisuals(B_CautionToggle, settings.Block.Caution, "Cautious: ON", "Cautious: OFF") end)

    D_Toggle.MouseButton1Click:Connect(function() settings.Dash.Enabled = not settings.Dash.Enabled; updateToggleVisuals(D_Toggle, settings.Dash.Enabled, "Dash Block: ON", "Dash Block: OFF") end)
    D_LookToggle.MouseButton1Click:Connect(function() settings.Dash.Look = not settings.Dash.Look; updateToggleVisuals(D_LookToggle, settings.Dash.Look, "Look At: ON", "Look At: OFF") end)
    D_MoveToggle.MouseButton1Click:Connect(function() settings.Dash.Move = not settings.Dash.Move; updateToggleVisuals(D_MoveToggle, settings.Dash.Move, "Auto Pos: ON", "Auto Pos: OFF") end)
    D_SmartToggle.MouseButton1Click:Connect(function() settings.Dash.Smart = not settings.Dash.Smart; updateToggleVisuals(D_SmartToggle, settings.Dash.Smart, "Smart Hold: ON", "Smart Hold: OFF") end)

    P_Toggle.MouseButton1Click:Connect(function() settings.Punch.Enabled = not settings.Punch.Enabled; updateToggleVisuals(P_Toggle, settings.Punch.Enabled, "Punch: ON", "Punch: OFF") end)
    P_LookToggle.MouseButton1Click:Connect(function() settings.Punch.Look = not settings.Punch.Look; updateToggleVisuals(P_LookToggle, settings.Punch.Look, "Look At: ON", "Look At: OFF") end)
    P_GlideToggle.MouseButton1Click:Connect(function() settings.Punch.Glide = not settings.Punch.Glide; updateToggleVisuals(P_GlideToggle, settings.Punch.Glide, "Glide: ON", "Glide: OFF") end)
    P_ComboToggle.MouseButton1Click:Connect(function() settings.Punch.Max3 = not settings.Punch.Max3; updateToggleVisuals(P_ComboToggle, settings.Punch.Max3, "Max 3 Hits: ON", "Max 3 Hits: OFF") end)

    M_SideDashToggle.MouseButton1Click:Connect(function() settings.Misc.SideDash = not settings.Misc.SideDash; updateToggleVisuals(M_SideDashToggle, settings.Misc.SideDash, "Side Dash: ON", "Side Dash: OFF") end)
    M_CamLockToggle.MouseButton1Click:Connect(function() settings.Misc.CamLock = not settings.Misc.CamLock; updateToggleVisuals(M_CamLockToggle, settings.Misc.CamLock, "Cam Lock: ON", "Cam Lock: OFF") end)

    -- Ability Toggle Connections (Simplified)
    A_MasterToggle.MouseButton1Click:Connect(function() 
        settings.Ability.Enabled = not settings.Ability.Enabled
        updateToggleVisuals(A_MasterToggle, settings.Ability.Enabled, "Abilities: ON", "Abilities: OFF")
        
        -- Update all abilities in the database
        for abilityId, abilityData in pairs(abilityDatabase) do
            abilityData.Enabled = settings.Ability.Enabled
        end
    end)

    A_LookToggle.MouseButton1Click:Connect(function() 
        settings.Ability.Look = not settings.Ability.Look
        updateToggleVisuals(A_LookToggle, settings.Ability.Look, "Look At: ON", "Look At: OFF")
        
        -- Update all abilities in the database
        for abilityId, abilityData in pairs(abilityDatabase) do
            abilityData.Look = settings.Ability.Look
        end
    end)

    A_MoveToggle.MouseButton1Click:Connect(function() 
        settings.Ability.Move = not settings.Ability.Move
        updateToggleVisuals(A_MoveToggle, settings.Ability.Move, "Auto Pos: ON", "Auto Pos: OFF")
        
        -- Update all abilities in the database
        for abilityId, abilityData in pairs(abilityDatabase) do
            abilityData.Move = settings.Ability.Move
        end
    end)

    A_SmartToggle.MouseButton1Click:Connect(function() 
        settings.Ability.Smart = not settings.Ability.Smart
        updateToggleVisuals(A_SmartToggle, settings.Ability.Smart, "Smart Hold: ON", "Smart Hold: OFF")
        
        -- Update all abilities in the database
        for abilityId, abilityData in pairs(abilityDatabase) do
            abilityData.Smart = settings.Ability.Smart
        end
    end)

    -- =================================================================================
    -- 8. LOGIC (INCLUDING ABILITY DETECTION WITH FIXED SETTINGS)
    -- =================================================================================

    local isBlocking = false
    local isAttacking = false
    local blockTask = nil 
    local lookAtActive = false
    local lookAtEndTime = 0
    local currentlyDashing = false
    local dashTarget = nil
    local lastSideDashTime = 0

    local function isRagdolled(char)
        if not char then return false end
        local comp = char:FindFirstChild("RagdollComponents")
        if not comp then return false end
        local total, active = 0, 0
        for _, child in pairs(comp:GetChildren()) do
            if child:IsA("BallSocketConstraint") then
                total = total + 1
                if child.Enabled then active = active + 1 end
            end
        end
        return total > 0 and (active / total) > 0.5
    end

    local function areWelded(myChar, targetChar)
        if not myChar or not targetChar then return false end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return false end
        for _, part in pairs(myRoot:GetConnectedParts(true)) do
            if part.Parent == targetChar or part.Parent.Parent == targetChar then return true end
        end
        local hum = myChar:FindFirstChild("Humanoid")
        if hum and (hum.Sit or hum:GetState() == Enum.HumanoidStateType.PlatformStanding) then return true end
        return false
    end

    local function getSafeLookCFrame(originPos, targetPos)
        local flatOrigin = Vector3.new(originPos.X, 0, originPos.Z)
        local flatTarget = Vector3.new(targetPos.X, 0, targetPos.Z)
        if (flatTarget - flatOrigin).Magnitude < 2 then return nil end 
        return CFrame.lookAt(flatOrigin, flatTarget)
    end

    local function addCharToCache(char)
        if not table.find(activeCharacters, char) then table.insert(activeCharacters, char) end
    end
    local function removeCharFromCache(char)
        local idx = table.find(activeCharacters, char)
        if idx then table.remove(activeCharacters, idx) end
    end

    local function getPredictedPos(char, predictionTime)
        local root = char:FindFirstChild("HumanoidRootPart")
        if not root then return Vector3.zero end
        return root.Position + (root.Velocity * predictionTime)
    end

    local function isNearbyPredicted(char, maxDist, predictionTime)
        if not Player.Character then return false end
        local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return false end
        local targetPos = getPredictedPos(char, predictionTime)
        return (myRoot.Position - targetPos).Magnitude <= maxDist
    end

    -- New function for ability blocking with FIXED settings
    local function triggerAbilityBlock(targetChar, trackObj, abilitySettings)
        if isRagdolled(Player.Character) then return end
        
        local cfg = abilitySettings -- Use the fixed settings from the ability database
        
        -- Check chance
        if math.random() > cfg.Chance then return end
        
        task.delay(cfg.Delay, function()
            if isRagdolled(Player.Character) then return end
            
            -- Auto Pos (Move to front)
            if cfg.Move then
                if not Player.Character then return end
                local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
                local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
                if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
                
                local direction = (myRoot.Position - targetRoot.Position).Unit
                local targetPos = targetRoot.Position + (direction * 3)
                local finalPos = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z)
                local safeLook = getSafeLookCFrame(finalPos, targetRoot.Position)
                if safeLook then
                    safeLook = safeLook + Vector3.new(0, myRoot.Position.Y, 0)
                    TweenService:Create(myRoot, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = safeLook}):Play()
                end
            end
            
            if not isBlocking then
                isBlocking = true
                sendRemote("Block", true)
                StatusLabel.Text = "ABILITY BLOCK"
                StatusLabel.TextColor3 = Color3.fromRGB(120, 180, 255) -- Blue color for abilities
            end
            
            if blockTask then task.cancel(blockTask) end
            
            -- Smart Hold Logic for abilities
            if cfg.Smart then
                StatusLabel.Text = "WAITING END"
                -- Wait for ability animation to end
                if trackObj and trackObj.IsPlaying then
                    local connection
                    connection = trackObj.Ended:Connect(function()
                        if connection then connection:Disconnect() end
                        task.wait(cfg.PostDelay or 0.1)
                        sendRemote("Block", false)
                        isBlocking = false
                        blockTask = nil
                        StatusLabel.Text = "IDLE"
                        StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                        
                        -- Counter-attack after ability block
                        if settings.Punch.Enabled then
                            if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
                                attemptPunch(targetChar) 
                            end
                        end
                    end)
                    
                    -- Safety timeout
                    task.delay(3, function()
                        if connection then connection:Disconnect() end
                        if isBlocking then
                            sendRemote("Block", false)
                            isBlocking = false
                            blockTask = nil
                            StatusLabel.Text = "IDLE"
                            StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                        end
                    end)
                else
                    -- Standard hold if no track object
                    blockTask = task.delay(cfg.Hold, function()
                        sendRemote("Block", false)
                        isBlocking = false
                        blockTask = nil
                        StatusLabel.Text = "IDLE"
                        StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                        
                        if settings.Punch.Enabled then
                            if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
                                attemptPunch(targetChar) 
                            end
                        end
                    end)
                end
            else
                -- Standard Hold
                blockTask = task.delay(cfg.Hold, function()
                    sendRemote("Block", false)
                    isBlocking = false
                    blockTask = nil
                    StatusLabel.Text = "IDLE"
                    StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                    
                    if settings.Punch.Enabled then
                        if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
                            attemptPunch(targetChar) 
                        end
                    end
                end)
            end
        end)
        
        -- Look At before blocking
        if cfg.Look then
            local lookStartDelay = math.max(0, cfg.Delay - cfg.PreDelay)
            task.delay(lookStartDelay, function()
                if areWelded(Player.Character, targetChar) then return end
                activateLookAt(cfg.LookTime)
            end)
        end
    end

    local function triggerSideDash(target)
        if isRagdolled(Player.Character) then return end
        local char = Player.Character
        if not char then return end
        local root = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")
        local animator = hum and hum:FindFirstChild("Animator")
        
        if not root or not hum or not animator then return end
        if hum.WalkSpeed < 1 then return end 
        
        local cooldown = tonumber(M_DashCD.Text) or 2
        if os.clock() - lastSideDashTime < cooldown then return end
        lastSideDashTime = os.clock()
        
        currentlyDashing = true
        dashTarget = target
        local isRight = math.random() > 0.5
        local dirMultiplier = isRight and 1 or -1
        local track = animator:LoadAnimation(isRight and dashAnimRight or dashAnimLeft)
        track:Play()
        
        local speed = tonumber(M_DashSpeed.Text) or 100
        local duration = tonumber(M_DashDecay.Text) or 0.3
        local startTime = os.clock()
        
        local connection
        connection = RunService.Heartbeat:Connect(function()
            if hum.WalkSpeed < 1 then
                if connection then connection:Disconnect() end
                currentlyDashing = false
                dashTarget = nil
                return
            end
            local elapsed = os.clock() - startTime
            if elapsed >= duration or not root.Parent then
                if connection then connection:Disconnect() end
                currentlyDashing = false
                dashTarget = nil
                root.AssemblyLinearVelocity = Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
                return
            end
            local alpha = elapsed / duration
            local currentSpeed = speed * (1 - (alpha * 0.7)) 
            local rightDir = root.CFrame.RightVector
            local oldVel = root.AssemblyLinearVelocity
            root.AssemblyLinearVelocity = (rightDir * currentSpeed * dirMultiplier) + Vector3.new(0, oldVel.Y, 0)
        end)
    end

    local function triggerGlide(targetChar)
        if not settings.Punch.Glide or isRagdolled(Player.Character) then return end
        local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
        if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
        
        local dist = (myRoot.Position - targetRoot.Position).Magnitude
        if dist > 3 and dist < 20 then
            local alpha = 0.3
            local newPos = myRoot.Position:Lerp(targetRoot.Position, alpha)
            local finalCF = getSafeLookCFrame(newPos, targetRoot.Position)
            if not finalCF then return end
            finalCF = finalCF + Vector3.new(0, myRoot.Position.Y, 0)
            TweenService:Create(myRoot, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = finalCF}):Play()
        end
    end

    local function triggerBlockGlide(targetChar)
        if not Player.Character then return end
        local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
        if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
        
        local direction = (myRoot.Position - targetRoot.Position).Unit
        local targetPos = targetRoot.Position + (direction * 3)
        local finalPos = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z)
        local safeLook = getSafeLookCFrame(finalPos, targetRoot.Position)
        if safeLook then
            safeLook = safeLook + Vector3.new(0, myRoot.Position.Y, 0)
            TweenService:Create(myRoot, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = safeLook}):Play()
        end
    end

    local function activateLookAt(duration)
        if isRagdolled(Player.Character) then return end
        lookAtEndTime = os.clock() + duration
        lookAtActive = true
    end

    local function attemptPunch(targetChar)
        if isAttacking or isRagdolled(Player.Character) then return end
        if isRagdolled(targetChar) then return end 
        if settings.Punch.Max3 and comboCooldownActive then return end 
        
        local chance = tonumber(P_Chance.Text) or 1
        if math.random() > chance then return end
        
        local delay = tonumber(P_Delay.Text) or 0.05
        local hold = tonumber(P_Hold.Text) or 0.1
        isAttacking = true
        
        task.delay(delay, function()
            if isRagdolled(Player.Character) then isAttacking = false return end
            sendRemote("M1", true)
            if settings.Punch.Look then
                local lookDuration = tonumber(P_LookTime.Text) or 0.35
                activateLookAt(lookDuration)
            end
            if targetChar then triggerGlide(targetChar) end
            StatusLabel.Text = "ATTACKING"
            StatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            task.delay(hold, function()
                sendRemote("M1", false)
                StatusLabel.Text = "IDLE"
                StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                isAttacking = false
            end)
        end)
    end

    local function triggerGenericBlock(targetChar, isDashBlock, trackObj)
        if isRagdolled(Player.Character) then return end
        
        local cfg = isDashBlock and {
            Delay = tonumber(D_Delay.Text), Hold = tonumber(D_Hold.Text),
            Look = settings.Dash.Look, Move = settings.Dash.Move,
            PreDelay = tonumber(D_PreDelay.Text), LookTime = tonumber(D_LookTime.Text),
            Smart = settings.Dash.Smart, PostDelay = tonumber(D_PostDelay.Text)
        } or {
            Delay = tonumber(B_Delay.Text), Hold = tonumber(B_Hold.Text),
            Look = settings.Block.Look, Move = settings.Block.Move,
            PreDelay = tonumber(B_PreDelay.Text), LookTime = tonumber(B_LookTime.Text),
            Smart = false 
        }
        
        task.delay(cfg.Delay or 0.16, function()
            if isRagdolled(Player.Character) then return end
            
            if cfg.Move then triggerBlockGlide(targetChar) end
            
            if not isBlocking then
                isBlocking = true
                sendRemote("Block", true)
                StatusLabel.Text = isDashBlock and "DASH BLOCK" or "BLOCKING"
                StatusLabel.TextColor3 = isDashBlock and Color3.fromRGB(255, 180, 80) or Color3.fromRGB(80, 255, 120)
            end
            
            if blockTask then task.cancel(blockTask) end
            
            -- Smart Hold Logic (Wait for Start)
            if cfg.Smart and isDashBlock then
                StatusLabel.Text = "WAITING END"
                local animator = targetChar:FindFirstChild("Animator", true)
                local endAnimTrack = nil
                if animator then
                    -- Check existing
                    for _, t in pairs(animator:GetPlayingAnimationTracks()) do
                        local id = string.match(t.Animation.AnimationId, "%d+")
                        if dashEnds[id] then endAnimTrack = t break end
                    end
                    -- Wait for new
                    if not endAnimTrack then
                        local connection
                        connection = animator.AnimationPlayed:Connect(function(t)
                            local id = string.match(t.Animation.AnimationId, "%d+")
                            if dashEnds[id] then endAnimTrack = t connection:Disconnect() end
                        end)
                        local timeout = 0
                        while not endAnimTrack and timeout < 1.5 do
                            timeout = timeout + RunService.Heartbeat:Wait()
                        end
                        if connection then connection:Disconnect() end
                    end
                end
                
                task.wait(cfg.PostDelay or 0.1)
                sendRemote("Block", false)
                isBlocking = false
                blockTask = nil
                StatusLabel.Text = "IDLE"
                StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                
                if settings.Punch.Enabled then
                    if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
                        attemptPunch(targetChar) 
                    end
                end
            else
                -- Standard Hold
                blockTask = task.delay(cfg.Hold or 0.12, function()
                    sendRemote("Block", false)
                    isBlocking = false
                    blockTask = nil
                    StatusLabel.Text = "IDLE"
                    StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                    
                    if settings.Punch.Enabled then
                        if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
                            attemptPunch(targetChar) 
                        end
                    end
                end)
            end
        end)
        
        if cfg.Look then
            local lookStartDelay = math.max(0, (cfg.Delay or 0.16) - (cfg.PreDelay or 0.05))
            task.delay(lookStartDelay, function()
                if areWelded(Player.Character, targetChar) then return end
                activateLookAt(cfg.LookTime or 0.5)
            end)
        end
    end

    local function hookAnimator(animator, char)
        animator.AnimationPlayed:Connect(function(track)
            if isRagdolled(Player.Character) then return end
            if not track.Animation then return end
            if char == Player.Character then return end
            
            local rawId = string.match(track.Animation.AnimationId, "%d+")
            
            -- M1 Detection
            if settings.Block.Enabled and m1Database[rawId] and not processedTracks[track] then
                local chance = tonumber(B_Chance.Text) or 1
                if math.random() > chance then return end
                local pred = tonumber(B_Pred.Text) or 0
                local reqDist = tonumber(B_Dist.Text) or 10
                if isNearbyPredicted(char, reqDist, pred) then
                    processedTracks[track] = true
                    track.Ended:Connect(function() processedTracks[track] = nil end)
                    triggerGenericBlock(char, false, track)
                end
            end
            
            -- Dash Detection
            if settings.Dash.Enabled and dashStarts[rawId] and not processedTracks[track] then
                local chance = tonumber(D_Chance.Text) or 1
                if math.random() > chance then return end
                local pred = tonumber(D_Pred.Text) or 0
                local reqDist = tonumber(D_Dist.Text) or 10
                if isNearbyPredicted(char, reqDist, pred) then
                    processedTracks[track] = true
                    track.Ended:Connect(function() processedTracks[track] = nil end)
                    triggerGenericBlock(char, true, track)
                end
            end
            
            -- Ability Detection (NEW) - Using FIXED settings
            if abilityDatabase[rawId] and not processedTracks[track] then
                local abilitySettings = abilityDatabase[rawId]
                
                -- Check if ability is enabled
                if not abilitySettings.Enabled then return end
                
                -- Check distance with ability's fixed settings
                local reqDist = abilitySettings.Dist or 30
                local pred = abilitySettings.Pred or 0
                if isNearbyPredicted(char, reqDist, pred) then
                    processedTracks[track] = true
                    track.Ended:Connect(function() processedTracks[track] = nil end)
                    triggerAbilityBlock(char, track, abilitySettings)
                end
            end
        end)
    end

    local function hookLocalCharacter(char)
        local hum = char:WaitForChild("Humanoid", 5)
        local animator = hum and hum:WaitForChild("Animator", 5)
        if not animator then return end
        
        animator.AnimationPlayed:Connect(function(track)
            if not track.Animation then return end
            local rawId = string.match(track.Animation.AnimationId, "%d+")
            
            if settings.Punch.Max3 and m1Database[rawId] then
                if os.clock() - lastLocalPunchTime > 1.5 then localComboCount = 0 end
                localComboCount = localComboCount + 1
                lastLocalPunchTime = os.clock()
                if localComboCount >= 3 then
                    comboCooldownActive = true
                    StatusLabel.Text = "COMBO COOLDOWN"
                    StatusLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
                    local cdTime = tonumber(P_ComboReset.Text) or 2
                    task.delay(cdTime, function()
                        comboCooldownActive = false
                        localComboCount = 0
                        StatusLabel.Text = "IDLE"
                        StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
                    end)
                end
            end
        end)
    end

    local function hookCharacter(char)
        if not char then return end
        addCharToCache(char)
        if char == Player.Character then hookLocalCharacter(char) return end
        local humanoid = char:FindFirstChild("Humanoid") or char:FindFirstChild("AnimationController")
        if not humanoid then humanoid = char:WaitForChild("Humanoid", 5) end
        if not humanoid then return end
        if humanoid:IsA("Humanoid") then humanoid.Died:Connect(function() removeCharFromCache(char) end) end
        char.AncestryChanged:Connect(function(_, parent) if not parent then removeCharFromCache(char) end end)
        local animator = humanoid:FindFirstChild("Animator")
        if not animator then animator = humanoid:WaitForChild("Animator", 5) end
        if not animator then return end
        hookAnimator(animator, char)
    end

    -- =================================================================================
    -- 9. RUNTIME LOOPS (UPDATED FOR ABILITY DETECTION)
    -- =================================================================================

    RunService.Heartbeat:Connect(function()
        if isRagdolled(Player.Character) then return end
        if not Player.Character then return end
        
        for _, char in pairs(activeCharacters) do
            if char ~= Player.Character and char.Parent then
                local animator = char:FindFirstChild("Animator", true)
                if animator then
                    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
                        local id = string.match(track.Animation.AnimationId, "%d+")
                        if not processedTracks[track] then
                            -- M1 Detection
                            if settings.Block.Enabled and m1Database[id] then
                                local pred = tonumber(B_Pred.Text) or 0
                                local reqDist = tonumber(B_Dist.Text) or 10
                                if isNearbyPredicted(char, reqDist, pred) then
                                    processedTracks[track] = true
                                    track.Ended:Connect(function() processedTracks[track] = nil end)
                                    triggerGenericBlock(char, false, track)
                                end
                            -- Dash Detection
                            elseif settings.Dash.Enabled and dashStarts[id] then
                                local pred = tonumber(D_Pred.Text) or 0
                                local reqDist = tonumber(D_Dist.Text) or 10
                                if isNearbyPredicted(char, reqDist, pred) then
                                    processedTracks[track] = true
                                    track.Ended:Connect(function() processedTracks[track] = nil end)
                                    triggerGenericBlock(char, true, track)
                                end
                            -- Ability Detection (NEW) - Using FIXED settings
                            elseif abilityDatabase[id] then
                                local abilitySettings = abilityDatabase[id]
                                
                                -- Check if ability is enabled
                                if not abilitySettings.Enabled then continue end
                                
                                -- Check distance with ability's fixed settings
                                local reqDist = abilitySettings.Dist or 30
                                local pred = abilitySettings.Pred or 0
                                if isNearbyPredicted(char, reqDist, pred) then
                                    processedTracks[track] = true
                                    track.Ended:Connect(function() processedTracks[track] = nil end)
                                    triggerAbilityBlock(char, track, abilitySettings)
                                end
                            end
                        end
                    end
                end
            end
        end
    end)

    task.spawn(function()
        while task.wait(1) do
            if not settings.Block.Caution or isRagdolled(Player.Character) or isBlocking then continue end
            local rate = tonumber(B_CautionRate.Text) or 0.05
            if math.random() > rate then continue end
            local dist = tonumber(B_CautionDist.Text) or 15
            local target = nil
            for _, char in pairs(activeCharacters) do
                if isNearbyPredicted(char, dist, 0) then target = char break end
            end
            if target then
                activateLookAt(0.5)
                sendRemote("Block", true)
                task.wait(0.2)
                sendRemote("Block", false)
            end
        end
    end)

    RunService.Heartbeat:Connect(function()
        if settings.Block.Enabled then return end 
        if not settings.Punch.Enabled or isRagdolled(Player.Character) then return end
        
        if not Player.Character then return end
        local atkDist = tonumber(P_Dist.Text) or 5
        local lookDist = tonumber(P_LookDist.Text) or 15
        
        local foundTarget = nil
        if currentlyDashing and dashTarget and dashTarget.Parent and isNearbyPredicted(dashTarget, lookDist, 0) then
            foundTarget = dashTarget
        else
            for _, char in pairs(activeCharacters) do
                if char ~= Player.Character and char.Parent then
                    if isNearbyPredicted(char, lookDist, 0) then foundTarget = char break end
                end
            end
        end
        
        if foundTarget then
            if isNearbyPredicted(foundTarget, atkDist, 0) then
                attemptPunch(foundTarget)
                if settings.Misc.SideDash then triggerSideDash(foundTarget) end
            elseif settings.Punch.Look then
                activateLookAt(0.1) 
            end
        end
    end)

    RunService.RenderStepped:Connect(function()
        if settings.Misc.CamLock then
            local camTarget = nil
            if currentlyDashing and dashTarget and dashTarget.Parent then camTarget = dashTarget
            else
                local closestDist = 100
                for _, char in pairs(activeCharacters) do
                    if char ~= Player.Character and char.Parent then
                        local targetRoot = char:FindFirstChild("HumanoidRootPart")
                        if targetRoot and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                            local dist = (Player.Character.HumanoidRootPart.Position - targetRoot.Position).Magnitude
                            if dist < closestDist then closestDist = dist camTarget = char end
                        end
                    end
                end
            end
            if camTarget and camTarget:FindFirstChild("HumanoidRootPart") then
                local cam = Workspace.CurrentCamera
                local smooth = tonumber(M_CamSmooth.Text) or 0.1
                local targetPos = camTarget.HumanoidRootPart.Position
                local goalCF = CFrame.lookAt(cam.CFrame.Position, targetPos)
                cam.CFrame = cam.CFrame:Lerp(goalCF, smooth)
            end
        end

        if (not lookAtActive and not currentlyDashing) or isRagdolled(Player.Character) then return end
        if not currentlyDashing and os.clock() > lookAtEndTime then lookAtActive = false return end
        
        if not Player.Character then return end
        local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        
        local targetChar = nil
        if currentlyDashing and dashTarget and dashTarget.Parent then targetChar = dashTarget
        else
            local closestDist = 50 
            for _, char in pairs(activeCharacters) do
                if char ~= Player.Character and char.Parent then
                    if areWelded(Player.Character, char) then continue end 
                    local targetRoot = char:FindFirstChild("HumanoidRootPart")
                    if targetRoot then
                        local dist = (myRoot.Position - targetRoot.Position).Magnitude
                        if dist < closestDist then closestDist = dist targetChar = char end
                    end
                end
            end
        end
        
        if targetChar then
            local targetPos = targetChar.HumanoidRootPart.Position
            local safeCF = getSafeLookCFrame(myRoot.Position, targetPos)
            if safeCF then
                local goalCF = safeCF + Vector3.new(0, myRoot.Position.Y, 0)
                if currentlyDashing then myRoot.CFrame = goalCF
                else myRoot.CFrame = myRoot.CFrame:Lerp(goalCF, 0.3) end
            end
        end
    end)

    if Player.Character then hookCharacter(Player.Character) end
    Player.CharacterAdded:Connect(hookCharacter)

    for _, desc in pairs(Workspace:GetDescendants()) do
        if desc:IsA("Model") and desc:FindFirstChild("Humanoid") then task.spawn(function() hookCharacter(desc) end) end
    end
    Workspace.DescendantAdded:Connect(function(desc)
        if desc:IsA("Model") and desc:FindFirstChild("Humanoid") then hookCharacter(desc) end
    end)
end)

print("Both scripts are now running concurrently!")
print("Script 1: THEY JUMPIN ME (ESP, Aimbot, Safe Zone)")
print("Script 2: Infinite Yield + Combat UI")
